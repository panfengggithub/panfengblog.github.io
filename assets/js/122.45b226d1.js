(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{535:function(v,e,_){"use strict";_.r(e);var p=_(1),n=Object(p.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"rocketmq的一些细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq的一些细节"}},[v._v("#")]),v._v(" "),e("strong",[v._v("RocketMq的一些细节")])]),v._v(" "),e("p",[v._v("1： RocketMq 默认消费行为是无序的， 但是可以保证局部有序（单队列内） 具体解决方案为：\n生产者发送消息时指定队列（根据业务IDHash等等。。。） ，同时消费者使用有序消费监听器（MessageListenerOrderly） 两者同时实现 即可保证局部有序")]),v._v(" "),e("p",[v._v("2： rocketmq的消息通讯机制是由推（push）拉（pull）两种方式实现 不过rocketmq对推送机制做了优化\n现在已不需要拉取了\nrocketmq的推送机制原理： 由客户端定时与mq发起pull长连接 若无消息返回 则间隔一定时间断开连接重连")]),v._v(" "),e("p",[v._v("3：消息长度的计算公式：topic名称长度+消息传递过去的参数+消息体大小+20b(日志数据大小)）=单条消息大小")]),v._v(" "),e("p",[v._v("单次批量发送消息大小最好不要超过1MB（会影响性能） 不能超过4MB（会直接报错） 可以通过消息分割解决(单条消息不能用消息分割)")]),v._v(" "),e("p",[v._v("4: MQ分布式事务解决方案的思想为数据最终一致\n即 A B 2个微服务事务操作， 不保证A B 事务操作的原子性 但保证2者100%执行成功")]),v._v(" "),e("p",[e("strong",[v._v("生产者组：")])]),v._v(" "),e("p",[v._v("当生产者组内有生产者无法提供事务回调的时候")]),v._v(" "),e("p",[v._v("就会由组内其他生产提供事务回调")]),v._v(" "),e("p",[v._v("**消费者组 ：\n** 同一组内消费者可以通过负载均衡和广播的形式消费topic  **\n**负载均衡：")]),v._v(" "),e("p",[v._v("此消费方式会按照6种逻辑均摊topic的消息：")]),v._v(" "),e("p",[v._v("1 AllocateMessageQueueAveragely：顺序分页")]),v._v(" "),e("p",[v._v("2:AllocateMessageQueueAveragelyByCircle 环状分页")]),v._v(" "),e("p",[v._v("3:AllocateMachineRoomNearby 就近机房")]),v._v(" "),e("p",[v._v("4: AllocateMessageQueueByMachineRoom 指定机房")]),v._v(" "),e("p",[v._v("5:AllocateMessageQueueByConfig 指定队列")]),v._v(" "),e("p",[v._v("6: AllocateMessageQueueConsistentHash hash环")]),v._v(" "),e("p",[v._v("注意 当消费者数量大于队列数量的时候 就会有消费者无法消费")]),v._v(" "),e("p",[v._v("广播：")]),v._v(" "),e("p",[v._v("此消费方式当topic每收到一条消息 所有以广播形式监听的消费者 都会收到这一条消息")]),v._v(" "),e("p",[v._v("消息重试：\n当mq没有接收到消费者消费响应 或是接收到重试响应 或是发生异常时\nmq就会重发此条消息\n每次重发会间隔不相等时间 间隔时间越来越大 最大2小时\n当重试默认到达16次时此消息就会进入死信队列\n死信队列默认禁止读写（即不能往里面发送消息和不能消费消息） 可以通过配置开启读写功能\n当产生死信消息时死信队列才会跟着创建")]),v._v(" "),e("p",[v._v("集群：\nrocketmq集群 总共4种角色\n生产者集群（组）")]),v._v(" "),e("p",[v._v("消费者集群（组）")]),v._v(" "),e("p",[v._v("生产者与消费者组之前已解释过")]),v._v(" "),e("p",[v._v("nameserver集群")]),v._v(" "),e("p",[v._v("nameserver集群之间并没有数据同步， 也没有任何的交互 当有新的nameserver加入集群时 broker会把自己的数据上报到新的nameserver 保持nameserver之间数据统一")]),v._v(" "),e("p",[v._v("broker集群")]),v._v(" "),e("p",[v._v("broker集群分为4种模式\n单主\n此模式即单独搭建一个 broker 就是咱们测试的模式， 一般只能作用于测试使用，不推荐线上使用， 一旦broker宕机 整个消息服务不可用\n多主")]),v._v(" "),e("p",[v._v("此模式优点在于配置简单且支持容错， 但是单主节点宕机会导致部分消息(存在于此节点上的消息)无法消费(无法消费不代表消息丢失， 当此节点恢复时 依然可以消费，也就是消息存在延迟)")]),v._v(" "),e("p",[v._v("多主多从:")]),v._v(" "),e("p",[v._v("多主多从模式 采用 主节点与从节点配合工作的模式架构 主节点提供读写 从节点只提供读")]),v._v(" "),e("p",[v._v("在消息发送这一块 只要有任意一个主节点(如果只剩下从节点存活 则消息发送不可用)存活 都不会影响消息发送")]),v._v(" "),e("p",[v._v("在消息消费这一块 只要有任意节点存活（无论主从） 消息均可消费")]),v._v(" "),e("p",[v._v("消息生产到主节点后 由主节点复制到从节点 完成消息的统一")]),v._v(" "),e("p",[v._v("同步\n即 同步方式去复制消息， 当复制消息完成后 才通知生产者\n异步")]),v._v(" "),e("p",[v._v("异步方式复制消息， 即收到消息后就通知生产者并异步复制消息 （对比同步模式， 效率提升约10%,但是当节点宕机，会出现少量消息丢失）")]),v._v(" "),e("p",[v._v("刷盘机制：\n刷盘 即 吧数据存储进磁盘的操作\n分为同步刷盘与异步刷盘")]),v._v(" "),e("p",[v._v("线上推荐使用的集群架构方案： 同步复制+异步刷盘 （消息100%不丢失，且一定程度保证效率）")]),v._v(" "),e("p",[e("strong",[v._v("课上那个重试的问题")])]),v._v(" "),e("p",[v._v("之所以上课演示的代码消费死信队列不会无限重试 我自己的测试代码却会无限重试\n是因为 消费死信队列的消费者 需要和死信队列属于的组 在同一组内（我上课的demo并不在一个组内 但是我自己的测试demo在一个组内）")])])}),[],!1,null,null,null);e.default=n.exports}}]);