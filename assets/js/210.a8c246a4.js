(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{624:function(_,v,a){"use strict";a.r(v);var e=a(1),p=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"java虚拟机-二"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机-二"}},[_._v("#")]),_._v(" Java虚拟机（二）")]),_._v(" "),v("p",[_._v("GC算法和收集器")]),_._v(" "),v("p",[_._v("本文参考：周志明《深入理解java虚拟机》第二版")]),_._v(" "),v("p",[_._v("如何判断对象可以被回收")]),_._v(" "),v("p",[_._v("堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）")]),_._v(" "),v("p",[_._v("引用计数法")]),_._v(" "),v("p",[_._v("给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0的对象就是不可能再被使用的。")]),_._v(" "),v("p",[_._v("这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决对象之前相互循环引用的问题。所谓对象之间的相互引用问题，通过下面代码所示：除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240531164-1894a33e-9eaf-4d8b-9e8f-8000ace7ea27.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_37%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"1.png"}})]),_._v(" "),v("p",[_._v("可达性分析算法")]),_._v(" "),v("p",[_._v("这个算法的基本思想就是通过一系列的称为”GC Roots“的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。")]),_._v(" "),v("p",[_._v("GC Roots根节点：类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240570837-42299d9b-1bd5-4128-ac53-46444f86efdb.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"8.png"}})]),_._v(" "),v("p",[_._v("如何判断一个常量是废弃常量")]),_._v(" "),v("p",[_._v("运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量时废弃常量呢？")]),_._v(" "),v("p",[_._v('假如在常量池中存在字符串"abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量”abc“就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc“会被系统清理出常量池。')]),_._v(" "),v("p",[_._v("如何判断一个类是无用的类")]),_._v(" "),v("p",[_._v("需要满足以下三个条件：")]),_._v(" "),v("p",[_._v("●该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。")]),_._v(" "),v("p",[_._v("●加载该类的 ClassLoader 已经被回收。")]),_._v(" "),v("p",[_._v("●该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。")]),_._v(" "),v("p",[_._v("虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是”可以“，而并不是和对象一样不适用了就必然会被回收。")]),_._v(" "),v("p",[_._v("垃圾回收算法")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240582127-5486c0ed-845c-4dcf-a239-3991ea4317ac.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"10.png"}})]),_._v(" "),v("p",[_._v("标记-清除算法")]),_._v(" "),v("p",[_._v("它是最基础的收集算法，这个算法分为两个阶段，“标记”和”清除“。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它有两个不足的地方：")]),_._v(" "),v("p",[_._v("1效率问题，标记和清除两个过程的效率都不高；")]),_._v(" "),v("p",[_._v("2空间问题，标记清除后会产生大量不连续的碎片；")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/564018/1574240853697-0931bcb5-eea3-477c-83c3-5a54b6197722.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"11.jpg"}})]),_._v(" "),v("p",[_._v("复制算法")]),_._v(" "),v("p",[_._v("为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/564018/1574240868415-bce31be5-ba51-4dbb-bb8c-f9d88d01177b.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"12.jpg"}})]),_._v(" "),v("p",[_._v("标记-整理算法")]),_._v(" "),v("p",[_._v("根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240884487-7de4db39-4ca9-4074-b90f-1dda4fb0b4fe.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"13.png"}})]),_._v(" "),v("p",[_._v("分代收集算法")]),_._v(" "),v("p",[_._v('现在的商用虚拟机的垃圾收集器基本都采用"分代收集"算法，这种算法就是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。')]),_._v(" "),v("p",[_._v("在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或者“标记-整理”算法进行垃圾收集")]),_._v(" "),v("p",[_._v("垃圾收集器")]),_._v(" "),v("p",[_._v("java虚拟机规范对垃圾收集器应该如何实现没有任何规定，因为没有所谓最好的垃圾收集器出现，更不会有万金油垃圾收集器，只能是根据具体的应用场景选择合适的垃圾收集器。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240906233-73a21447-44b1-430a-9074-b5b99680fb1b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"14.png"}})]),_._v(" "),v("p",[_._v("Serial收集器")]),_._v(" "),v("p",[_._v("Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。")]),_._v(" "),v("p",[_._v("新生代采用复制算法，老年代采用标记-整理算法。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/564018/1574240923691-10ca75de-23ca-43a9-87e2-4ad008d24327.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"15.jpg"}})]),_._v(" "),v("p",[_._v("虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。")]),_._v(" "),v("p",[_._v("但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器")]),_._v(" "),v("p",[_._v("对于运行在Client模式下的虚拟机来说是个不错的选择。")]),_._v(" "),v("p",[_._v("ParNew收集器")]),_._v(" "),v("p",[_._v("ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。")]),_._v(" "),v("p",[_._v("新生代采用复制算法，老年代采用标记-整理算法。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/564018/1574240937795-cbdd35ce-321e-4389-8a3d-5fb4f938d241.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"16.jpg"}})]),_._v(" "),v("p",[_._v("它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。")]),_._v(" "),v("p",[_._v("Parallel Scavenge收集器(JDK1.8)")]),_._v(" "),v("p",[_._v("Parallel Scavenge 收集器类似于ParNew 收集器。")]),_._v(" "),v("p",[_._v("Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。")]),_._v(" "),v("p",[_._v("新生代采用复制算法，老年代采用标记-整理算法。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/564018/1574240942000-7a903d67-da8f-4f82-b66a-aa8e0c716572.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"17.jpg"}})]),_._v(" "),v("p",[_._v("Serial Old收集器")]),_._v(" "),v("p",[_._v("Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。")]),_._v(" "),v("p",[_._v("Parallel Old收集器")]),_._v(" "),v("p",[_._v("Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。")]),_._v(" "),v("p",[_._v("CMS收集器")]),_._v(" "),v("p",[_._v("并行和并发概念补充：")]),_._v(" "),v("p",[_._v("●并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。")]),_._v(" "),v("p",[_._v("●并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。")]),_._v(" "),v("p",[_._v("CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。")]),_._v(" "),v("p",[_._v("CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。")]),_._v(" "),v("p",[_._v("从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：")]),_._v(" "),v("p",[_._v("●初始标记（CMS initial mark）： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快")]),_._v(" "),v("p",[_._v("●并发标记（CMS concurrent mark）： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。")]),_._v(" "),v("p",[_._v("●重新标记（CMS remark）： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短")]),_._v(" "),v("p",[_._v("●并发清除（CMS concurrent sweep）： 开启用户线程，同时GC线程开始对为标记的区域做清扫。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/564018/1574240953993-f91d1d7d-45cf-451e-81e4-fcf17baa4828.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"18.jpg"}})]),_._v(" "),v("p",[_._v("CMS主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：")]),_._v(" "),v("p",[_._v("●对CPU资源敏感；")]),_._v(" "),v("p",[_._v("●无法处理浮动垃圾；")]),_._v(" "),v("p",[_._v("●它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。")]),_._v(" "),v("p",[_._v("G1收集器")]),_._v(" "),v("p",[_._v("G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240958319-74d3f0e6-3016-4a1e-86cd-58627ef17c75.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"19.png"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240975910-c910bb02-01d9-41ed-8eeb-9005e36fcc9a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"20.png"}})]),_._v(" "),v("p",[_._v("被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：")]),_._v(" "),v("p",[_._v("●并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行")]),_._v(" "),v("p",[_._v("●分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的")]),_._v(" "),v("p",[_._v("●可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内")]),_._v(" "),v("p",[_._v("G1收集器的运作大致分为以下几个步骤：")]),_._v(" "),v("p",[_._v("●初始标记")]),_._v(" "),v("p",[_._v("●并发标记")]),_._v(" "),v("p",[_._v("●最终标记")]),_._v(" "),v("p",[_._v("●筛选回收")]),_._v(" "),v("p",[_._v("G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。")]),_._v(" "),v("p",[_._v("怎么选择垃圾收集器？")]),_._v(" "),v("p",[_._v("1优先调整堆的大小让服务器自己来选择")]),_._v(" "),v("p",[_._v("2如果内存小于100m，使用串行收集器")]),_._v(" "),v("p",[_._v("3如果是单核，并且没有停顿时间的要求，串行或JVM自己选择")]),_._v(" "),v("p",[_._v("4如果允许停顿时间超过1秒，选择并行或者JVM自己选")]),_._v(" "),v("p",[_._v("5如果响应时间最重要，并且不能超过1秒，使用并发收集器")]),_._v(" "),v("p",[_._v("官方推荐G1，性能高。")]),_._v(" "),v("p",[_._v("JDK性能调优监控工具")]),_._v(" "),v("p",[_._v("Jinfo")]),_._v(" "),v("p",[_._v("查看正在运行的Java程序的扩展参数")]),_._v(" "),v("p",[_._v("查看JVM的参数")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240991013-0789fcee-7f1f-4851-bb43-395738a13b43.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"jinfo1.png"}})]),_._v(" "),v("p",[_._v("查看java系统属性")]),_._v(" "),v("p",[_._v("等同于System.getProperties()")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574240995655-3842bf59-02af-47d9-b0e9-baa24b7ac725.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"jinfo2.png"}})]),_._v(" "),v("p",[_._v("Jstat")]),_._v(" "),v("p",[_._v("jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令格式：")]),_._v(" "),v("p",[_._v("jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]")]),_._v(" "),v("p",[_._v("Jmap")]),_._v(" "),v("p",[_._v("可以用来查看内存信息")]),_._v(" "),v("p",[_._v("堆的对象统计")]),_._v(" "),v("p",[_._v("jmap -histo 7824 > xxx.txt")]),_._v(" "),v("p",[_._v("如图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574241015826-9dd6919b-ceb2-4e1d-9270-238495e9b2cc.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"jmap1.png"}})]),_._v(" "),v("p",[_._v("●Num：序号")]),_._v(" "),v("p",[_._v("●Instances：实例数量")]),_._v(" "),v("p",[_._v("●Bytes：占用空间大小")]),_._v(" "),v("p",[_._v("●Class Name：类名")]),_._v(" "),v("p",[_._v("堆信息")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574241023464-f79385b0-0a96-4e8f-be90-abff7562028e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"jmap2.png"}})]),_._v(" "),v("p",[_._v("堆内存dump")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574241028133-06b67eb0-56a0-4f6f-8745-13a8d3de48a0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_11%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"jmap3.png"}})]),_._v(" "),v("p",[_._v("jmap -dump:format=b,file=temp.hprof")]),_._v(" "),v("p",[_._v("也可以在设置内存溢出的时候自动导出dump文件（项目内存很大的时候，可能会导不出来）")]),_._v(" "),v("p",[_._v("1.-XX:+HeapDumpOnOutOfMemoryError")]),_._v(" "),v("p",[_._v("2.-XX:HeapDumpPath=输出路径")]),_._v(" "),v("p",[_._v("-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:\\oomdump.dump")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574241045813-247c52cc-2ba0-44ab-8509-d496c060b190.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"jmap4.png"}})]),_._v(" "),v("p",[_._v("可以使用jvisualvm命令工具导入文件分析")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574241278584-e443d518-0e51-4992-83ad-354c6f7c4aa6.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"jmap5.png"}})]),_._v(" "),v("p",[_._v("Jstack")]),_._v(" "),v("p",[_._v("jstack用于生成java虚拟机当前时刻的线程快照。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/png/564018/1574241287753-cbfa44e2-4338-4de6-9ece-71d6ee1e2d9d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"jstack.png"}})]),_._v(" "),v("p",[_._v("调优")]),_._v(" "),v("p",[_._v("JVM调优主要就是调整下面两个指标")]),_._v(" "),v("p",[_._v("停顿时间：垃圾收集器做垃圾回收中断应用执行的时间。-XX:MaxGCPauseMillis")]),_._v(" "),v("p",[_._v("吞吐量：垃圾收集的时间和总时间的占比：1/(1+n),吞吐量为1-1/(1+n)。-XX:GCTimeRatio=n")]),_._v(" "),v("p",[_._v("GC调优步骤")]),_._v(" "),v("p",[_._v("1.打印GC日志")]),_._v(" "),v("p",[_._v("-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:./gc.log")]),_._v(" "),v("p",[_._v("Tomcat可以直接加载JAVA_OPTS变量里")]),_._v(" "),v("p",[_._v("2.分析日志得到关键性指标")]),_._v(" "),v("p",[_._v("3.分析GC原因，调优JVM参数")]),_._v(" "),v("p",[_._v("1.Parallel Scavenge收集器(默认)")]),_._v(" "),v("p",[_._v("分析parallel-gc.log")]),_._v(" "),v("p",[_._v("第一次调优，设置Metaspace大小：增大元空间大小-XX:MetaspaceSize=64M  -XX:MaxMetaspaceSize=64M")]),_._v(" "),v("p",[_._v("第二次调优，增大年轻代动态扩容增量（默认是20%），可以减少YGC：-XX:YoungGenerationSizeIncrement=30")]),_._v(" "),v("p",[_._v("比较下几次调优效果：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("吞吐量")]),_._v(" "),v("th",[_._v("最大停顿")]),_._v(" "),v("th",[_._v("平均停顿")]),_._v(" "),v("th",[_._v("YGC")]),_._v(" "),v("th",[_._v("FGC")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("97.467%")]),_._v(" "),v("td",[_._v("370 ms")]),_._v(" "),v("td",[_._v("50.0 ms")]),_._v(" "),v("td",[_._v("16")]),_._v(" "),v("td",[_._v("2")])]),_._v(" "),v("tr",[v("td",[_._v("98.9%")]),_._v(" "),v("td",[_._v("110 ms")]),_._v(" "),v("td",[_._v("32.5 ms")]),_._v(" "),v("td",[_._v("12")]),_._v(" "),v("td",[_._v("0")])])])]),_._v(" "),v("p",[_._v("2.配置CMS收集器")]),_._v(" "),v("p",[_._v("-XX:+UseConcMarkSweepGC")]),_._v(" "),v("p",[_._v("分析gc-cms.log")]),_._v(" "),v("p",[_._v("3.配置G1收集器")]),_._v(" "),v("p",[_._v("-XX:+UseG1GC")]),_._v(" "),v("p",[_._v("分析gc-g1.log")]),_._v(" "),v("p",[_._v("young GC:[GC pause (G1 Evacuation Pause)(young)")]),_._v(" "),v("p",[_._v("initial-mark:[GC pause  (Metadata GC Threshold)(young)(initial-mark) (参数：InitiatingHeapOccupancyPercent)")]),_._v(" "),v("p",[_._v("mixed GC:[GC pause (G1 Evacuation Pause)(Mixed) (参数：G1HeapWastePercent)")]),_._v(" "),v("p",[_._v("full GC:[Full GC (Allocation Failure)(无可用region)")]),_._v(" "),v("p",[_._v("（G1内部，前面提到的混合GC是非常重要的释放内存机制，它避免了G1出现Region没有可用的情况，否则就会触发 FullGC事件。CMS、Parallel、Serial GC都需要通过Full GC去压缩老年代并在这个过程中扫描整个老年代。G1的Full GC算法和Serial GC收集器完全一致。当一个Full GC发生时，整个Java堆执行一个完整的压缩，这样确保了最大的空余内存可用。G1的Full GC是一个单线程，它可能引起一个长时间的停顿时间，G1的设计目标是减少Full GC，满足应用性能目标。）")]),_._v(" "),v("p",[_._v("查看发生MixedGC的阈值：jinfo -flag InitiatingHeapOccupancyPercent 进程ID")]),_._v(" "),v("p",[_._v("调优：")]),_._v(" "),v("p",[_._v("第一次调优，设置Metaspace大小：增大元空间大小-XX:MetaspaceSize=64M  -XX:MaxMetaspaceSize=64M")]),_._v(" "),v("p",[_._v("第二次调优，添加吞吐量和停顿时间参数：-XX:GCTimeRatio=99 -XX:MaxGCPauseMillis=10")]),_._v(" "),v("p",[_._v("GC常用参数")]),_._v(" "),v("p",[_._v("堆栈设置")]),_._v(" "),v("p",[_._v("-Xss:每个线程的栈大小")]),_._v(" "),v("p",[_._v("-Xms:初始堆大小，默认物理内存的1/64")]),_._v(" "),v("p",[_._v("-Xmx:最大堆大小，默认物理内存的1/4")]),_._v(" "),v("p",[_._v("-Xmn:新生代大小")]),_._v(" "),v("p",[_._v("-XX:NewSize:设置新生代初始大小")]),_._v(" "),v("p",[_._v("-XX:NewRatio:默认2表示新生代占年老代的1/2，占整个堆内存的1/3。")]),_._v(" "),v("p",[_._v("-XX:SurvivorRatio:默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。")]),_._v(" "),v("p",[_._v("-XX:MetaspaceSize:设置元空间大小")]),_._v(" "),v("p",[_._v("-XX:MaxMetaspaceSize:设置元空间最大允许大小，默认不受限制，JVM Metaspace会进行动态扩展。")]),_._v(" "),v("p",[_._v("垃圾回收统计信息")]),_._v(" "),v("p",[_._v("-XX:+PrintGC")]),_._v(" "),v("p",[_._v("-XX:+PrintGCDetails")]),_._v(" "),v("p",[_._v("-XX:+PrintGCTimeStamps")]),_._v(" "),v("p",[_._v("-Xloggc:filename")]),_._v(" "),v("p",[_._v("收集器设置")]),_._v(" "),v("p",[_._v("-XX:+UseSerialGC:设置串行收集器")]),_._v(" "),v("p",[_._v("-XX:+UseParallelGC:设置并行收集器")]),_._v(" "),v("p",[_._v("-XX:+UseParallelOldGC:老年代使用并行回收收集器")]),_._v(" "),v("p",[_._v("-XX:+UseParNewGC:在新生代使用并行收集器")]),_._v(" "),v("p",[_._v("-XX:+UseParalledlOldGC:设置并行老年代收集器")]),_._v(" "),v("p",[_._v("-XX:+UseConcMarkSweepGC:设置CMS并发收集器")]),_._v(" "),v("p",[_._v("-XX:+UseG1GC:设置G1收集器")]),_._v(" "),v("p",[_._v("-XX:ParallelGCThreads:设置用于垃圾回收的线程数")]),_._v(" "),v("p",[_._v("并行收集器设置")]),_._v(" "),v("p",[_._v("-XX:ParallelGCThreads:设置并行收集器收集时使用的CPU数。并行收集线程数。")]),_._v(" "),v("p",[_._v("-XX:MaxGCPauseMillis:设置并行收集最大暂停时间")]),_._v(" "),v("p",[_._v("-XX:GCTimeRatio:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)")]),_._v(" "),v("p",[_._v("CMS收集器设置")]),_._v(" "),v("p",[_._v("-XX:+UseConcMarkSweepGC:设置CMS并发收集器")]),_._v(" "),v("p",[_._v("-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。")]),_._v(" "),v("p",[_._v("-XX:ParallelGCThreads:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。")]),_._v(" "),v("p",[_._v("-XX:CMSFullGCsBeforeCompaction:设定进行多少次CMS垃圾回收后，进行一次内存压缩")]),_._v(" "),v("p",[_._v("-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收")]),_._v(" "),v("p",[_._v("-XX:UseCMSInitiatingOccupancyOnly:表示只在到达阀值的时候，才进行CMS回收")]),_._v(" "),v("p",[_._v("-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况")]),_._v(" "),v("p",[_._v("-XX:ParallelCMSThreads:设定CMS的线程数量")]),_._v(" "),v("p",[_._v("-XX:CMSInitiatingOccupancyFraction:设置CMS收集器在老年代空间被使用多少后触发")]),_._v(" "),v("p",[_._v("-XX:+UseCMSCompactAtFullCollection:设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理")]),_._v(" "),v("p",[_._v("G1收集器设置")]),_._v(" "),v("p",[_._v("-XX:+UseG1GC:使用G1收集器")]),_._v(" "),v("p",[_._v("-XX:ParallelGCThreads:指定GC工作的线程数量")]),_._v(" "),v("p",[_._v("-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区")]),_._v(" "),v("p",[_._v("-XX:GCTimeRatio:吞吐量大小，0-100的整数(默认9)，值为n则系统将花费不超过1/(1+n)的时间用于垃圾收集")]),_._v(" "),v("p",[_._v("-XX:MaxGCPauseMillis:目标暂停时间(默认200ms)")]),_._v(" "),v("p",[_._v("-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%)")]),_._v(" "),v("p",[_._v("-XX:G1MaxNewSizePercent:新生代内存最大空间")]),_._v(" "),v("p",[_._v("-XX:TargetSurvivorRatio:Survivor填充容量(默认50%)")]),_._v(" "),v("p",[_._v("-XX:MaxTenuringThreshold:最大任期阈值(默认15)")]),_._v(" "),v("p",[_._v("-XX:InitiatingHeapOccupancyPercen:老年代占用空间超过整堆比IHOP阈值(默认45%),超过则执行混合收集")]),_._v(" "),v("p",[_._v("-XX:G1HeapWastePercent:堆废物百分比(默认5%)")]),_._v(" "),v("p",[_._v("-XX:G1MixedGCCountTarget:参数混合周期的最大总次数(默认8)")])])}),[],!1,null,null,null);v.default=p.exports}}]);