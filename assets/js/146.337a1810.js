(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{560:function(e,a,r){"use strict";r.r(a);var c=r(1),p=Object(c.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"paxos算法笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paxos算法笔记"}},[e._v("#")]),e._v(" "),a("strong",[e._v("Paxos算法笔记")])]),e._v(" "),a("h2",{attrs:{id:"一个proposal-一个acceptor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个proposal-一个acceptor"}},[e._v("#")]),e._v(" 一个Proposal，一个Acceptor")]),e._v(" "),a("h3",{attrs:{id:"锁机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁机制"}},[e._v("#")]),e._v(" 锁机制")]),e._v(" "),a("h4",{attrs:{id:"acceptor上的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#acceptor上的属性"}},[e._v("#")]),e._v(" Acceptor上的属性：")]),e._v(" "),a("ol",[a("li",[e._v("变量var")]),e._v(" "),a("li",[e._v("一个互斥锁lock")])]),e._v(" "),a("h4",{attrs:{id:"acceptor上的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#acceptor上的方法"}},[e._v("#")]),e._v(" Acceptor上的方法：")]),e._v(" "),a("ol",[a("li",[e._v("Acceptor:prepare() : 可以获取锁以及var的值")]),e._v(" "),a("li",[e._v("Acceptor:release() : 可以释放锁")]),e._v(" "),a("li",[e._v("Acceptor:accept(var, Value)  : 如果已经加锁，并且var没有值，则设置var为Value，并且释放锁")])]),e._v(" "),a("h4",{attrs:{id:"porposal两阶段实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#porposal两阶段实现"}},[e._v("#")]),e._v(" Porposal两阶段实现：")]),e._v(" "),a("ol",[a("li",[e._v("通过Acceptor:prepare()来获取锁以及var的值，如果不能，表示锁被占用")]),e._v(" "),a("li",[e._v("如果获取var的值为null，则调用Acceptor:accept(var, Value)来设置值")]),e._v(" "),a("li",[e._v("如果获取var的值不为null,则Acceptor:release()释放锁")])]),e._v(" "),a("h4",{attrs:{id:"存在问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[e._v("#")]),e._v(" 存在问题")]),e._v(" "),a("p",[e._v("Porposal获取锁之后，如果系统故障，没有释放锁，导致系统死锁")]),e._v(" "),a("h3",{attrs:{id:"抢占式机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抢占式机制"}},[e._v("#")]),e._v(" 抢占式机制")]),e._v(" "),a("p",[e._v("Acceptor可以让某个Proposal获取到的访问权直接失效掉，不再接收它的访问，之后，可以将访问权发放给其他Proposal，让其他Proposal访问Acceptor，可以避免了死锁。")]),e._v(" "),a("p",[e._v("Acceptor上存在版本号epoch（时间戳），Proposal提交时要指定epoch，epoch越大权利越大。")]),e._v(" "),a("p",[e._v("Acceptor采用喜新厌旧的原则，一旦接收到epoch越大的权限申请请求，马上让旧的epoch的访问权失效，不再接收他们提交的值。")]),e._v(" "),a("p",[e._v("然后给新的epoch发放访问权\t，只接收新epoch提交的值。")]),e._v(" "),a("p",[e._v("为了保证一致性，不同epoch的Proposal需要采用后者认同前者的原则")]),e._v(" "),a("ol",[a("li",[e._v("在肯定旧的epoch无法生成确定性取值的情况下，新的epoch会提交自己的value,不会冲突")]),e._v(" "),a("li",[e._v("一旦旧的epoch生成了确定性取值，新的epoch肯定可以获取到该值，并且会认同此值，不会修改。")])]),e._v(" "),a("h4",{attrs:{id:"acceptor上的属性-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#acceptor上的属性-2"}},[e._v("#")]),e._v(" Acceptor上的属性：")]),e._v(" "),a("ol",[a("li",[e._v("当前var的取值 <currentEpoch, currentValue>，设置该Value的epoch")]),e._v(" "),a("li",[e._v("最新发放访问权的epoch <latest_prepared_epoch>，获得权限的epoch")])]),e._v(" "),a("h4",{attrs:{id:"acceptor上的方法-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#acceptor上的方法-2"}},[e._v("#")]),e._v(" Acceptor上的方法")]),e._v(" "),a("p",[e._v("Acceptor:prepare(epoch) 表示传过来的epoch能不能拥有访问权")]),e._v(" "),a("ol",[a("li",[e._v("只接收比latest_prepared_epoch大的epoch,并给与访问权")]),e._v(" "),a("li",[e._v("记录latest_prepared_epoch= epoch,返回当前var的值")])]),e._v(" "),a("p",[e._v("Acceptor:accept(var, prepared_epoch, value) 表示prepared_epoch理论上已经拥有访问权了，现在修改var的值为value")]),e._v(" "),a("ol",[a("li",[e._v("验证latest_prepared_epoch 是否等于 prepared_epoch")]),e._v(" "),a("li",[e._v("如果等于，则设置var的值 <currentepoch, currentValue> = <prepared_epoch, value>")]),e._v(" "),a("li",[e._v("如果不等于，则表示访问权被其他Proposal抢了过去，本次操作失败")])]),e._v(" "),a("h4",{attrs:{id:"proposal的两阶段实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proposal的两阶段实现"}},[e._v("#")]),e._v(" Proposal的两阶段实现")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("生成epoch，调用Acceptor:prepare(epoch)获取访问权和当前Acceptor上的值，如果不能获取到访问权，则操作失败")])]),e._v(" "),a("li",[a("p",[e._v("如果获取到访问权，采用后者认同前缀的原则，")])]),e._v(" "),a("li",[a("ol",[a("li",[e._v("如果第一阶段返回的值为空,则肯定旧的epoch没有形成确定性取值，则通过Acceptor:accept(var, prepared_epoch, value)提交新的取值，如果accept方法执行失败，则证明被新的epoch抢占了访问权或者accept故障")]),e._v(" "),a("li",[e._v("如果第一阶段返回的值存在，不为空，那么直接认同它，不再进行第二阶段，直接向客户端返回<ok， accepted_value>")])])])]),e._v(" "),a("h2",{attrs:{id:"多个acceptor的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个acceptor的情况"}},[e._v("#")]),e._v(" 多个Acceptor的情况")]),e._v(" "),a("p",[e._v("Paxos算法就是多个Acceptor。")]),e._v(" "),a("p",[e._v("Acceptor实现方式不变，仍然采用喜新厌旧的原则，Paxos采用少数服从多数的思路。")]),e._v(" "),a("p",[e._v("一旦某个epoch想要设置的值被半数以上的Acceptor接受，则认为此值被确定，不再更改")]),e._v(" "),a("h4",{attrs:{id:"paxos的proposal两阶段属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paxos的proposal两阶段属性"}},[e._v("#")]),e._v(" Paxos的Proposal两阶段属性")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("第一阶段，先生成epoch，调用Acceptor:prepare(epoch)方法获取访问权和对应的var的取值，需要获取到半数以上Acceptor的访问权和对应的var的值。")])]),e._v(" "),a("li",[a("p",[e._v("第二阶段，如果获取到半数一下的访问权，则进行第二阶段，仍然采用后者认同前者的原则")])]),e._v(" "),a("li",[a("ol",[a("li",[e._v("如果获得了访问权的Acceptor返回的值都为空，则表示旧的epoch没有形成确定性取值，调用accept方法努力使<新epoch，新value>成为确定性取值")])])]),e._v(" "),a("li",[a("ol",[a("li",[a("ol",[a("li",[e._v("向获取到了访问权的Acceptor提交取值<新epoch，新value>")]),e._v(" "),a("li",[e._v("如果没有成功，则表示有更新的epoch抢占了某个Acceptor，或者某个Acceptor故障了")])])])])]),e._v(" "),a("li",[a("ol",[a("li",[e._v("如果获得了访问权的Acceptor返回的值不都为空，则表示旧的epoch形成了确定性取值，新的epoch只能用该值，不能设置自己的新值，Proposal会取该值作为传递给accept方法的值，以使得那些值还为空的Acceptor得到一致的值")])])])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.yuque.com/attachments/yuque/0/2020/pdf/365147/1590310698169-9f0d70b0-ee9a-41ec-b01a-949450b2843c.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("📎Zookeeper-paxos算法详解.pdf"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=p.exports}}]);