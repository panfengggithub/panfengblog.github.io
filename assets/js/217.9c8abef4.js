(window.webpackJsonp=window.webpackJsonp||[]).push([[217],{630:function(_,v,e){"use strict";e.r(v);var a=e(1),t=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"nginx原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nginx原理"}},[_._v("#")]),_._v(" "),v("strong",[_._v("nginx原理")])]),_._v(" "),v("h2",{attrs:{id:"多进程模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多进程模型"}},[_._v("#")]),_._v(" 多进程模型")]),_._v(" "),v("p",[_._v("进程是操作系统资源分配的最小单位，由于 CPU 数量有限，多个进程间通过被分配的时间片来获得 CPU 的使用权，系统在进行内核管理和进程调度时，要执行保存当前进程上下文、更新控制信息、选择另一就绪进程、恢复就绪进程上下文等一系列操作，而频繁切换进程会造成资源消耗。")]),_._v(" "),v("p",[_._v("Nginx 采用的是固定数量的多进程模型，由一个主进程和数量与主机 CPU 核数相同的工作进程协同处理各种事件。主进程负责工作进程的配置加载、启停等操作，工作进程负责处理具体请求")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/gif/1618119/1610112181150-c962aa3f-13ae-45ac-b339-87ceb21a2124.gif",alt:"img"}})]),_._v(" "),v("p",[_._v("进程间的资源都是独立的，每个工作进程处理多个连接，每个连接由一个工作进程全权处理，不需要进行进程切换，也就不会产生由进程切换引起的资源消耗问题。默认配置下，工作进程的数量与主机 CPU 核数相同，充分利用 CPU 和进程的亲缘性（affinity）将工作进程与 CPU 绑定，从而最大限度地发挥多核 CPU 的处理能力。")]),_._v(" "),v("p",[_._v("Nginx 主进程负责监听外部控制信号，通过频道机制将相关信号操作传递给工作进程，多个工作进程间通过共享内存来共享数据和信息。")]),_._v(" "),v("p",[_._v("主进程（Master Process）主要完成如下工作：")]),_._v(" "),v("ol",[v("li",[_._v("读取并验正配置信息；")]),_._v(" "),v("li",[_._v("创建、绑定及关闭套接字；")]),_._v(" "),v("li",[_._v("启动、终止及维护worker进程的个数；")]),_._v(" "),v("li",[_._v("无须中止服务而重新配置工作特性；")]),_._v(" "),v("li",[_._v("控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；")]),_._v(" "),v("li",[_._v("重新打开日志文件，实现日志滚动；")]),_._v(" "),v("li",[_._v("编译嵌入式perl脚本")])]),_._v(" "),v("p",[_._v("工作进程（Worker Process）")]),_._v(" "),v("ol",[v("li",[_._v("接收、传入并处理来自客户端的连接；")]),_._v(" "),v("li",[_._v("提供反向代理及过滤功能；")]),_._v(" "),v("li",[_._v("nginx任何能完成的其它任务；")])]),_._v(" "),v("h3",{attrs:{id:"进程调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程调度"}},[_._v("#")]),_._v(" 进程调度")]),_._v(" "),v("p",[_._v("当工作进程被创建时，每个工作进程都继承了主进程的监听套接字（socket），所以所有工作进程的事件监听列表中会共享相同的监听套接字。但是多个工作进程间同一时间内只能由一个工作进程接收网络连接，为使多个工作进程间能够协调工作，Nginx 的工作进程有如下几种调度方式。")]),_._v(" "),v("ul",[v("li",[_._v("无调度模式\n惊群效应：连接事件被触发时会唤醒所有工作进程，与客户端建立连接，建立连接成功则开始处理客户端请求。所有进程都会争抢资源，但最终只有一个进程可以与客户端建立连接，对于系统而言这将在瞬间产生大量的资源消耗。")]),_._v(" "),v("li",[_._v("互斥锁模式（accept_mutex）\n互斥锁是一种声明机制，每个工作进程都会周期性地争抢互斥锁，一旦某个工作进程抢到互斥锁，就表示其拥有接收 HTTP 建立连接事件的处理权，并将当前进程的 socket 监听注入事件引擎（如 epoll）中，接收外部的连接事件。\n其他工作进程只能继续处理已经建立连接的读写事件，并周期性地轮询查看互斥锁的状态，只有互斥锁被释放后工作进程才可以抢占互斥锁，获取 HTTP 建立连接事件的处理权。当工作进程最大连接数的 1/8 与该进程可用连接（free_connection）的差大于或等于 1 时，则放弃本轮争抢互斥锁的机会，不再接收新的连接请求，只处理已建立连接的读写事件。\n互斥锁模式有效地避免了惊群现象，对于大量 HTTP 的短连接，该机制有效避免了因工作进程争抢事件处理权而产生的资源消耗。但对于大量启用长连接方式的 HTTP 连接，互斥锁模式会将压力集中在少数工作进程上，进而因工作进程负载不均而导致 QPS 下降。")]),_._v(" "),v("li",[_._v("套接字分片（Socket Sharding）\n套接字分片是由内核提供的一种分配机制，该机制允许每个工作进程都有一组相同的监听套接字。当有外部连接请求时，由内核决定哪个工作进程的套接字监听可以接收连接。这有效避免了惊群现象的发生，相比互斥锁机制提高了多核系统的性能。该功能需要在配置 listen 指令时启用 so_reuseport 参数。")])]),_._v(" "),v("p",[_._v("Nginx 1.11.3 以后的版本中互斥锁模式默认是关闭的，由于 Nginx 的工作进程数量有限，且 Nginx 通常会在高并发场景下应用，很少有空闲的工作进程，所以惊群现象的影响不大。无调度模式因少了争抢互斥锁的处理，在高并发场景下可提高系统的响应能力。套接字分片模式则因为由 Linux 内核提供进程的调度机制，所以性能最好。")]),_._v(" "),v("h3",{attrs:{id:"多进程和多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多进程和多线程"}},[_._v("#")]),_._v(" 多进程和多线程")]),_._v(" "),v("p",[_._v("nginx使用多进程而不是多线程的原因：")]),_._v(" "),v("p",[_._v("多线程:")]),_._v(" "),v("p",[_._v("共享一块进程空间，存在并发问题需要问题")]),_._v(" "),v("p",[_._v("cpu在线程间的切换会消耗大量资源，")]),_._v(" "),v("p",[_._v("线程发生异常会影响整个进程")]),_._v(" "),v("p",[_._v("多进程+单线程:")]),_._v(" "),v("p",[_._v("进程之间空间独立不需要处理并发问题")]),_._v(" "),v("p",[_._v("进程与cpu绑定的机制，节省了cpu切换时间")]),_._v(" "),v("p",[_._v("健壮性：一个进程异常不会影响其他进程")]),_._v(" "),v("h3",{attrs:{id:"缓存机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存机制"}},[_._v("#")]),_._v(" 缓存机制")]),_._v(" "),v("p",[_._v("Cache模块，主要由缓存加载（缓存索引重建Cache Loader）和缓存管理（缓存索引管理Cache Manager）两类进程完成工作。缓存索引重建进程是在Nginx服务启动一段时间之后（默认是1分钟）由主进程生成，在缓存元数据重建完成后就自动退出；缓存索引管理进程一般存在于主进程的整个生命周期，负责对缓存索引进行管理。")]),_._v(" "),v("p",[_._v("cache loader进程主要完成的任务包括：")]),_._v(" "),v("ol",[v("li",[_._v("检查缓存存储中的缓存对象；")]),_._v(" "),v("li",[_._v("使用缓存元数据建立内存数据库；")])]),_._v(" "),v("p",[_._v("cache manager进程的主要任务：")]),_._v(" "),v("ol",[v("li",[_._v("缓存的失效及过期检验；")])]),_._v(" "),v("p",[_._v("默认只对 GET 和 HEAD 方法的请求进行缓存，如果想对 POST 请求方法的数据进行缓存，则可以使用 proxy_cache_methods 指令进行设置。")]),_._v(" "),v("p",[_._v("proxy_cache_methods GET HEAD POST;")]),_._v(" "),v("p",[_._v("缓存加载进程在nginx启动时，从磁盘加载缓存文件，将缓存元数据(缓存索引)存储到共享内存,为避免缓存加载影响nginx整体性能，可以设置加载参数，按迭代进行加载")]),_._v(" "),v("p",[_._v("proxy_cache_path /data/cache keys_zone=niyueling:10m loader_threshold=300 loader_files=200;")]),_._v(" "),v("p",[_._v("loader_threshold - 迭代的持续时间，以毫秒为单位(默认为200)")]),_._v(" "),v("p",[_._v("loader_files - 在一次迭代期间加载的最大项目数(默认为100)")]),_._v(" "),v("p",[_._v("loader_sleeps - 迭代之间的延迟(以毫秒为单位)(默认为50)")]),_._v(" "),v("p",[_._v("缓存管理进程：定期检查缓存状态、查看缓存总量是否超出限制、如果超出，就移除其中最少使用的部分")]),_._v(" "),v("h2",{attrs:{id:"信号机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号机制"}},[_._v("#")]),_._v(" 信号机制")]),_._v(" "),v("p",[_._v("kill -HUP "),v("code",[_._v("cat /data/nginx/nginx.pid")])]),_._v(" "),v("ul",[v("li",[_._v("CHLD：当worker进程出现异常关闭时，会给master进程发送该信号，master进程收到信号会重启worker进程")]),_._v(" "),v("li",[_._v("TERM, INT: 这两个信号都是立即停止服务，而不会等待已连接的tcp处理完请求")]),_._v(" "),v("li",[_._v("QUIT: 优雅的停止服务，不会立刻断开用户的tcp连接")]),_._v(" "),v("li",[_._v("HUP: 重载配置文件")]),_._v(" "),v("li",[_._v("USR1: 重新打开日志文件，可以做日志文件的切割")]),_._v(" "),v("li",[_._v("USR2: 启动新的master主进程")]),_._v(" "),v("li",[_._v("WINCH: 让master进程优雅的关闭所有的worker进程。")])]),_._v(" "),v("p",[_._v("reload流程：")]),_._v(" "),v("p",[_._v("1、向master进程发送HUP信号")]),_._v(" "),v("p",[_._v("2、master进程校验配置语法是否正确")]),_._v(" "),v("p",[_._v("3、master进程打开新的监听端口(如果有)")]),_._v(" "),v("p",[_._v("4、master进程用新的配置启动新的worker子进程")]),_._v(" "),v("p",[_._v("5、master进程向老的worker子进程发送QUIT信号")]),_._v(" "),v("p",[_._v("6、老worker进程关闭监听句柄，处理完当前连接后结束进程")]),_._v(" "),v("p",[_._v("热升级流程：")]),_._v(" "),v("p",[_._v("1、将旧的nginx文件换成新的nginx文件（替换binary文件，即sbin目录下的nginx文件  cp -f 备份）")]),_._v(" "),v("p",[_._v("2、向master进程发送USR2信号")]),_._v(" "),v("p",[_._v("3、master进程修改pid文件名，加后缀.oldbin")]),_._v(" "),v("p",[_._v("4、master进程用新nginx文件启动新master进程")]),_._v(" "),v("p",[_._v("5、向老的master进程发送WINCH信号，关闭老的worker")]),_._v(" "),v("p",[_._v("6、回滚：向老的master发送HUP，向新的master发送QUIT")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/1618119/1610517194309-94ced5b7-5d6c-4297-9557-44f82fb871ed.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_47%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/1618119/1610514192036-29db23a4-5d99-4829-ac87-571bd3042f6e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_78%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/1618119/1610514205185-22b94d53-dcbc-4f73-aac1-93e8ee627749.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_68%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})])])}),[],!1,null,null,null);v.default=t.exports}}]);