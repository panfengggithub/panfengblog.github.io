(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{505:function(a,s,t){"use strict";t.r(s);var n=t(1),e=Object(n.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"_1-常见的集合有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-常见的集合有哪些"}},[a._v("#")]),a._v(" 1. 常见的集合有哪些？")]),a._v(" "),s("p",[a._v("Java集合类主要由两个根接口"),s("strong",[a._v("Collection")]),a._v("和"),s("strong",[a._v("Map")]),a._v("派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。")]),a._v(" "),s("p",[s("strong",[a._v("注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口")]),a._v("。")]),a._v(" "),s("p",[a._v("Java集合框架图如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/image-20210403163733569.png",alt:""}})]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/image-20210403163751501.png",alt:""}})]),a._v(" "),s("p",[a._v("图中，List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。")]),a._v(" "),s("p",[a._v("Map代表的是存储key-value对的集合，可根据元素的key来访问value。")]),a._v(" "),s("p",[a._v("上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。")]),a._v(" "),s("h2",{attrs:{id:"_2-线程安全的集合有哪些-线程不安全的呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程安全的集合有哪些-线程不安全的呢"}},[a._v("#")]),a._v(" 2. 线程安全的集合有哪些？线程不安全的呢？")]),a._v(" "),s("p",[a._v("线程安全的：")]),a._v(" "),s("ul",[s("li",[a._v("Hashtable：比HashMap多了个线程安全。")]),a._v(" "),s("li",[a._v("ConcurrentHashMap:是一种高效但是线程安全的集合。")]),a._v(" "),s("li",[a._v("Vector：比Arraylist多了个同步化机制。")]),a._v(" "),s("li",[a._v("Stack：栈，也是线程安全的，继承于Vector。")])]),a._v(" "),s("p",[a._v("线性不安全的：")]),a._v(" "),s("ul",[s("li",[a._v("HashMap")]),a._v(" "),s("li",[a._v("Arraylist")]),a._v(" "),s("li",[a._v("LinkedList")]),a._v(" "),s("li",[a._v("HashSet")]),a._v(" "),s("li",[a._v("TreeSet")]),a._v(" "),s("li",[a._v("TreeMap")])]),a._v(" "),s("h2",{attrs:{id:"_3-arraylist与-linkedlist-异同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-arraylist与-linkedlist-异同点"}},[a._v("#")]),a._v(" 3. Arraylist与 LinkedList 异同点？")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("是否保证线程安全：")]),a._v(" ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；")]),a._v(" "),s("li",[s("strong",[a._v("底层数据结构：")]),a._v(" Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；")]),a._v(" "),s("li",[s("strong",[a._v("插入和删除是否受元素位置的影响：")]),a._v(" "),s("strong",[a._v("ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。")]),a._v(" 比如：执行"),s("code",[a._v("add(E e)")]),a._v("方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（"),s("code",[a._v("add(int index, E element)")]),a._v("）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。  "),s("strong",[a._v("LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。")])]),a._v(" "),s("li",[s("strong",[a._v("是否支持快速随机访问：")]),a._v(" LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于"),s("code",[a._v("get(int index)")]),a._v("方法)。")]),a._v(" "),s("li",[s("strong",[a._v("内存空间占用：")]),a._v(" ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。")])]),a._v(" "),s("h2",{attrs:{id:"_4-arraylist-与-vector-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-arraylist-与-vector-区别"}},[a._v("#")]),a._v(" 4. ArrayList 与 Vector 区别？")]),a._v(" "),s("ul",[s("li",[a._v("Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。")]),a._v(" "),s("li",[a._v("ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。")])]),a._v(" "),s("h2",{attrs:{id:"_5-说一说arraylist-的扩容机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-说一说arraylist-的扩容机制"}},[a._v("#")]),a._v(" 5. 说一说ArrayList 的扩容机制？")]),a._v(" "),s("p",[a._v("ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。"),s("strong",[a._v("默认情况下，新的容量会是原容量的1.5倍")]),a._v("。")]),a._v(" "),s("p",[a._v("以JDK1.8为例说明:")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("E")]),a._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("ensureCapacityInternal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("size "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Increments modCount!!")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//将e添加到数组末尾")]),a._v("\n    elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("size"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。通过ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，经过处理之后将元素存储在数组elementData的尾部")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("ensureCapacityInternal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("ensureExplicitCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("calculateCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("calculateCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("elementData "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DEFAULTCAPACITY_EMPTY_ELEMENTDATA")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("max")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DEFAULT_CAPACITY")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    \n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("ensureExplicitCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        modCount"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；如果最低要求的存储能力>ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，因此需要调用 grow();方法进行扩容")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("minCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("grow")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("grow")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 获取elementData数组的内存空间长度")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 扩容至原来的1.5倍")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//校验容量是否够")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" minCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n            newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//若预设值大于默认的最大值，检查是否溢出")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("MAX_ARRAY_SIZE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n            newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hugeCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 调用Arrays.copyOf方法将elementData数组指向新的内存空间")]),a._v("\n         "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//并将elementData的数据复制到新的内存空间")]),a._v("\n        elementData "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Arrays")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("copyOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" newCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br"),s("span",{staticClass:"line-number"},[a._v("33")]),s("br"),s("span",{staticClass:"line-number"},[a._v("34")]),s("br"),s("span",{staticClass:"line-number"},[a._v("35")]),s("br"),s("span",{staticClass:"line-number"},[a._v("36")]),s("br"),s("span",{staticClass:"line-number"},[a._v("37")]),s("br"),s("span",{staticClass:"line-number"},[a._v("38")]),s("br"),s("span",{staticClass:"line-number"},[a._v("39")]),s("br"),s("span",{staticClass:"line-number"},[a._v("40")]),s("br"),s("span",{staticClass:"line-number"},[a._v("41")]),s("br"),s("span",{staticClass:"line-number"},[a._v("42")]),s("br"),s("span",{staticClass:"line-number"},[a._v("43")]),s("br"),s("span",{staticClass:"line-number"},[a._v("44")]),s("br"),s("span",{staticClass:"line-number"},[a._v("45")]),s("br")])]),s("h2",{attrs:{id:"_6-array-和-arraylist-有什么区别-什么时候该应-array-而不是-arraylist-呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-array-和-arraylist-有什么区别-什么时候该应-array-而不是-arraylist-呢"}},[a._v("#")]),a._v(" 6. Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。")])]),a._v(" "),s("li",[s("p",[a._v("Array 大小是固定的，ArrayList 的大小是动态变化的。")])]),a._v(" "),s("li",[s("p",[a._v("ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。")])]),a._v(" "),s("li")]),a._v(" "),s("h2",{attrs:{id:"_7-hashmap的底层数据结构是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-hashmap的底层数据结构是什么"}},[a._v("#")]),a._v(" 7. HashMap的底层数据结构是什么？")]),a._v(" "),s("p",[a._v("在JDK1.7 和JDK1.8 中有所差别：")]),a._v(" "),s("p",[a._v("在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。")]),a._v(" "),s("p",[a._v("在JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("当链表超过 8 且数据总量超过 64 才会转红黑树。")])]),a._v(" "),s("li",[s("p",[a._v("将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。")])])]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/image-20210112185830788.png",alt:"Jdk1.8 HashMap结构"}})]),a._v(" "),s("h2",{attrs:{id:"_8-解决hash冲突的办法有哪些-hashmap用的哪种"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-解决hash冲突的办法有哪些-hashmap用的哪种"}},[a._v("#")]),a._v(" 8. 解决hash冲突的办法有哪些？HashMap用的哪种？")]),a._v(" "),s("p",[a._v("解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法 。")]),a._v(" "),s("ul",[s("li",[a._v("开放定址法也称为"),s("code",[a._v("再散列法")]),a._v("，基本思想就是，如果"),s("code",[a._v("p=H(key)")]),a._v("出现冲突时，则以"),s("code",[a._v("p")]),a._v("为基础，再次hash，"),s("code",[a._v("p1=H(p)")]),a._v(",如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址"),s("code",[a._v("pi")]),a._v("。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以"),s("code",[a._v("只能在删除的节点上做标记，而不能真正删除节点。")])]),a._v(" "),s("li",[a._v("再哈希法(双重散列，多重散列)，提供多个不同的hash函数，当"),s("code",[a._v("R1=H1(key1)")]),a._v("发生冲突时，再计算"),s("code",[a._v("R2=H2(key1)")]),a._v("，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。")]),a._v(" "),s("li",[a._v("链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。")]),a._v(" "),s("li",[a._v("建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。")])]),a._v(" "),s("h2",{attrs:{id:"_9-为什么在解决-hash-冲突的时候-不直接用红黑树-而选择先用链表-再转红黑树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-为什么在解决-hash-冲突的时候-不直接用红黑树-而选择先用链表-再转红黑树"}},[a._v("#")]),a._v(" 9. 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?")]),a._v(" "),s("p",[a._v("因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。")]),a._v(" "),s("p",[a._v("因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。")]),a._v(" "),s("h2",{attrs:{id:"_10-hashmap默认加载因子是多少-为什么是-0-75-不是-0-6-或者-0-8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-hashmap默认加载因子是多少-为什么是-0-75-不是-0-6-或者-0-8"}},[a._v("#")]),a._v(" 10. HashMap默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？")]),a._v(" "),s("p",[a._v("回答这个问题前，我们来先看下HashMap的默认构造函数：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" threshold"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 容纳键值对的最大值")]),a._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("float")]),a._v(" loadFactor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 负载因子")]),a._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" modCount"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。")]),a._v(" "),s("p",[a._v("默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。")])]),a._v(" "),s("li",[s("p",[a._v("相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。")])])]),a._v(" "),s("p",[a._v("我们来追溯下作者在源码中的注释（JDK1.7）：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("As")]),a._v(" a general rule"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" the "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("default")]),a._v(" load factor "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v(".75")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" offers a good tradeoff between time and space "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("costs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v(" Higher")]),a._v(" values decrease the space overhead but increase the lookup cost "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("reflected in most of the operations of the "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashMap")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" including get and put"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("The")]),a._v(" expected number of entries in the map and its load factor should be taken into account when setting its initial capacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" so as "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("to")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("minimize")]),a._v(" the number of rehash "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("operations"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v(" If")]),a._v(" the initial capacity is greater than the maximum number of entries divided by the load factor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" no rehash operations will ever occur"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。")]),a._v(" "),s("h2",{attrs:{id:"_11-hashmap-中-key-的存储索引是怎么计算的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-hashmap-中-key-的存储索引是怎么计算的"}},[a._v("#")]),a._v(" 11. HashMap 中  key 的存储索引是怎么计算的？")]),a._v(" "),s("p",[a._v("首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&（length-1）计算得到存储的位置。看看源码的实现：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// jdk1.7")]),a._v("\n方法一：\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" hashSeed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&&")]),a._v(" k "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instanceof")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("sun"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("misc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("Hashing")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("stringHash32")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^=")]),a._v(" k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 为第一步：取hashCode值")]),a._v("\n    h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n方法二：\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("indexFor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样")]),a._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//第三步：取模运算")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br")])]),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// jdk1.8")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("   \n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* \n     h = key.hashCode() 为第一步：取hashCode值\n     h ^ (h >>> 16)  为第二步：高位参与运算\n    */")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])]),s("p",[a._v("这里的 Hash 算法本质上就是三步："),s("strong",[a._v("取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标")]),a._v("。其中，JDK1.7和1.8的不同之处，就在于第二步。我们来看下详细过程，以JDK1.8为例，n为table的长度。")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/image-20210112191920111.png",alt:"image-20210112191920111"}})]),a._v(" "),s("h2",{attrs:{id:"_12-hashmap-的put方法流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-hashmap-的put方法流程"}},[a._v("#")]),a._v(" 12. HashMap 的put方法流程？")]),a._v(" "),s("p",[a._v("简要流程如下：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；")])]),a._v(" "),s("li",[s("p",[a._v("如果数组是空的，则调用 resize 进行初始化；")])]),a._v(" "),s("li",[s("p",[a._v("如果没有哈希冲突直接放在对应的数组下标里；")])]),a._v(" "),s("li",[s("p",[a._v("如果冲突了，且 key 已经存在，就覆盖掉 value；")])]),a._v(" "),s("li",[s("p",[a._v("如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；")])]),a._v(" "),s("li",[s("p",[a._v("如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/hashmap%E4%B9%8Bput%E6%96%B9%E6%B3%95.jpg",alt:"hashmap之put方法(JDK1.8)"}})])])]),a._v(" "),s("h2",{attrs:{id:"_13-hashmap-的扩容方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-hashmap-的扩容方式"}},[a._v("#")]),a._v(" 13. HashMap 的扩容方式？")]),a._v(" "),s("p",[a._v("HashMap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 HashMap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。")]),a._v(" "),s("p",[a._v("那扩容的具体步骤是什么？让我们看看源码。")]),a._v(" "),s("p",[a._v("先来看下JDK1.7 的代码：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("resize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" newCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//传入新的容量")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" oldTable "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//引用扩容前的Entry数组")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" oldTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("MAXIMUM_CAPACITY")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//扩容前的数组大小如果已经达到最大(2^30)了")]),a._v("\n            threshold "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("MAX_VALUE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" newTable "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("newCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//初始化一个新的Entry数组")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("transfer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                         "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//！！将数据转移到新的Entry数组里")]),a._v("\n        table "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                           "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//HashMap的table属性引用新的Entry数组")]),a._v("\n        threshold "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" loadFactor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//修改阈值")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br")])]),s("p",[a._v("这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("transfer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" src "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//src引用了旧的Entry数组")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" src"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" j"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//遍历旧的Entry数组")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" e "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" src"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//取得旧Entry数组的每个元素")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("e "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                src"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("do")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" next "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("indexFor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" newCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//！！重新计算每个元素在数组中的位置")]),a._v("\n                    e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//标记[1]")]),a._v("\n                    newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("      "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//将元素放在数组上")]),a._v("\n                    e "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//访问下一个Entry链上的元素")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("e "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br")])]),s("p",[a._v("newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。")]),a._v(" "),s("h2",{attrs:{id:"_14-一般用什么作为hashmap的key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-一般用什么作为hashmap的key"}},[a._v("#")]),a._v(" 14. 一般用什么作为HashMap的key?")]),a._v(" "),s("p",[a._v("一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。")]),a._v(" "),s("ul",[s("li",[a._v("因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。")]),a._v(" "),s("li",[a._v("因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。")])]),a._v(" "),s("h2",{attrs:{id:"_15-hashmap为什么线程不安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-hashmap为什么线程不安全"}},[a._v("#")]),a._v(" 15. HashMap为什么线程不安全？")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.png",alt:""}})]),a._v(" "),s("ul",[s("li",[a._v("多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。")]),a._v(" "),s("li",[a._v("多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。")]),a._v(" "),s("li",[a._v("put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。")])]),a._v(" "),s("p",[a._v("具体分析可见我的这篇文章："),s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg4MjUxMTI4NA==&mid=2247484436&idx=1&sn=eb677611e2ba1d10e3eb3ceb825bef02&chksm=cf54d8cff82351d9cb1c6ad49b6df8b7f0eaa7b965e3be5546b449e71ce1ffccf47ae68f7bf7&token=1920060057&lang=zh_CN#rd",target:"_blank",rel:"noopener noreferrer"}},[a._v("面试官：HashMap 为什么线程不安全？"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"_16-concurrenthashmap-的实现原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-concurrenthashmap-的实现原理是什么"}},[a._v("#")]),a._v(" 16. ConcurrentHashMap 的实现原理是什么？")]),a._v(" "),s("p",[a._v("ConcurrentHashMap  在 JDK1.7 和 JDK1.8  的实现方式是不同的。")]),a._v(" "),s("p",[s("strong",[a._v("先来看下JDK1.7")])]),a._v(" "),s("p",[a._v("JDK1.7中的ConcurrentHashMap  是由 "),s("code",[a._v("Segment")]),a._v(" 数组结构和 "),s("code",[a._v("HashEntry")]),a._v(" 数组结构组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。")]),a._v(" "),s("p",[a._v("其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/ConcurrentHashMap-jdk1.7.png",alt:""}})]),a._v(" "),s("p",[a._v("首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。")]),a._v(" "),s("p",[s("strong",[a._v("再来看下JDK1.8")])]),a._v(" "),s("p",[a._v("在数据结构上， JDK1.8  中的ConcurrentHashMap  选择了与 HashMap 相同的"),s("strong",[a._v("数组+链表+红黑树")]),a._v("结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用"),s("code",[a._v("CAS + synchronized")]),a._v("实现更加低粒度的锁。")]),a._v(" "),s("p",[a._v("将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/ConcurrentHashMap-jdk1.8.png",alt:""}})]),a._v(" "),s("h2",{attrs:{id:"_17-concurrenthashmap-的-put-方法执行逻辑是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-concurrenthashmap-的-put-方法执行逻辑是什么"}},[a._v("#")]),a._v(" 17. ConcurrentHashMap  的 put 方法执行逻辑是什么？")]),a._v(" "),s("p",[s("strong",[a._v("先来看JDK1.7")])]),a._v(" "),s("p",[a._v("首先，会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁。")]),a._v(" "),s("p",[a._v("获取到锁后：")]),a._v(" "),s("ol",[s("li",[a._v("将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。")]),a._v(" "),s("li",[a._v("遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。")]),a._v(" "),s("li",[a._v("不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。")]),a._v(" "),s("li",[a._v("释放 Segment 的锁。")])]),a._v(" "),s("p",[s("strong",[a._v("再来看JDK1.8")])]),a._v(" "),s("p",[a._v("大致可以分为以下步骤：")]),a._v(" "),s("ol",[s("li",[a._v("根据 key 计算出 hash值。")]),a._v(" "),s("li",[a._v("判断是否需要进行初始化。")]),a._v(" "),s("li",[a._v("定位到 Node，拿到首节点 f，判断首节点 f：\n"),s("ul",[s("li",[a._v("如果为  null  ，则通过cas的方式尝试添加。")]),a._v(" "),s("li",[a._v("如果为 "),s("code",[a._v("f.hash = MOVED = -1")]),a._v(" ，说明其他线程在扩容，参与一起扩容。")]),a._v(" "),s("li",[a._v("如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。")])])]),a._v(" "),s("li",[a._v("当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。")])]),a._v(" "),s("p",[a._v("源码分析可看这篇文章："),s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=Mzg4MjUxMTI4NA==&mid=2247484715&idx=1&sn=f5c3ad8e66122531a1c77efcb9cb50b7&chksm=cf54d9f0f82350e637a51fa8bc679f6197d15e4c9703aac971150bfcc5437e867c3bcf3f409c&token=1920060057&lang=zh_CN#rd",target:"_blank",rel:"noopener noreferrer"}},[a._v("面试 ConcurrentHashMap ，看这一篇就够了！"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"_18-concurrenthashmap-的-get-方法是否要加锁-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-concurrenthashmap-的-get-方法是否要加锁-为什么"}},[a._v("#")]),a._v(" 18. ConcurrentHashMap 的 get 方法是否要加锁，为什么？")]),a._v(" "),s("p",[a._v("get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。")]),a._v(" "),s("p",[a._v("这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 安全效率高的原因之一。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Node")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Entry")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//可以看到这些都用了volatile修饰")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),a._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Node")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("h2",{attrs:{id:"_19-get方法不需要加锁与volatile修饰的哈希桶有关吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-get方法不需要加锁与volatile修饰的哈希桶有关吗"}},[a._v("#")]),a._v(" 19. get方法不需要加锁与volatile修饰的哈希桶有关吗？")]),a._v(" "),s("p",[a._v("没有关系。哈希桶"),s("code",[a._v("table")]),a._v("用volatile修饰主要是保证在数组扩容的时候保证可见性。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Segment")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ReentrantLock")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Serializable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 存放数据的桶")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("transient")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashEntry")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("h2",{attrs:{id:"_20-concurrenthashmap-不支持-key-或者-value-为-null-的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-concurrenthashmap-不支持-key-或者-value-为-null-的原因"}},[a._v("#")]),a._v(" 20. ConcurrentHashMap  不支持 key 或者 value 为  null  的原因？")]),a._v(" "),s("p",[a._v("我们先来说value 为什么不能为 null ，因为"),s("code",[a._v("ConcurrentHashMap")]),a._v("是用于多线程的 ，如果"),s("code",[a._v("map.get(key)")]),a._v("得到了 null ，无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，这就有了二义性。")]),a._v(" "),s("p",[a._v("而用于单线程状态的"),s("code",[a._v("HashMap")]),a._v("却可以用"),s("code",[a._v("containsKey(key)")]),a._v(" 去判断到底是否包含了这个 null 。")]),a._v(" "),s("p",[a._v("我们用"),s("strong",[a._v("反证法")]),a._v("来推理：")]),a._v(" "),s("p",[a._v("假设ConcurrentHashMap 允许存放值为 null 的value，这时有A、B两个线程，线程A调用ConcurrentHashMap .get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。")]),a._v(" "),s("p",[a._v("假设此时，返回为 null 的真实情况是没有找到对应的key。那么，我们可以用ConcurrentHashMap .containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回false。")]),a._v(" "),s("p",[a._v("但是在我们调用ConcurrentHashMap .get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap .put(key, null )的操作。那么我们调用containsKey方法返回的就是true了，这就与我们的假设的真实情况不符合了，这就有了二义性。")]),a._v(" "),s("p",[a._v("至于ConcurrentHashMap 中的key为什么也不能为 null 的问题，源码就是这样写的，哈哈。如果面试官不满意，就回答因为作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的key存在。想要深入了解的小伙伴，可以看这篇文章"),s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzIxNTQ4MzE1NA==&mid=2247484354&idx=1&sn=80c92881b47a586eba9c633eb78d36f6&chksm=9796d5bfa0e15ca9713ff9dc6e100593e0ef06ed7ea2f60cb984e492c4ed438d2405fbb2c4ff&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[a._v("这道面试题我真不知道面试官想要的回答是什么"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"_21-concurrenthashmap-的并发度是多少"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-concurrenthashmap-的并发度是多少"}},[a._v("#")]),a._v(" 21. ConcurrentHashMap 的并发度是多少？")]),a._v(" "),s("p",[a._v("在JDK1.7中，并发度默认是16，这个值可以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。")]),a._v(" "),s("h2",{attrs:{id:"_22-concurrenthashmap-迭代器是强一致性还是弱一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-concurrenthashmap-迭代器是强一致性还是弱一致性"}},[a._v("#")]),a._v(" 22. ConcurrentHashMap 迭代器是强一致性还是弱一致性？")]),a._v(" "),s("p",[a._v("与HashMap迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。")]),a._v(" "),s("p",[a._v("ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。")]),a._v(" "),s("p",[a._v("这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。想要深入了解的小伙伴，可以看这篇文章[为什么ConcurrentHashMap 是弱一致的](http://ifeve.com/ConcurrentHashMap -weakly-consistent/)")]),a._v(" "),s("h2",{attrs:{id:"_23-jdk1-7与jdk1-8-中concurrenthashmap-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_23-jdk1-7与jdk1-8-中concurrenthashmap-的区别"}},[a._v("#")]),a._v(" 23. JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？")]),a._v(" "),s("ul",[s("li",[a._v("数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。")]),a._v(" "),s("li",[a._v("保证线程安全机制：JDK1.7采用Segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8 采用CAS+Synchronized保证线程安全。")]),a._v(" "),s("li",[a._v("锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。")]),a._v(" "),s("li",[a._v("链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。")]),a._v(" "),s("li",[a._v("查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。")])]),a._v(" "),s("h2",{attrs:{id:"_24-concurrenthashmap-和hashtable的效率哪个更高-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_24-concurrenthashmap-和hashtable的效率哪个更高-为什么"}},[a._v("#")]),a._v(" 24. ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？")]),a._v(" "),s("p",[a._v("ConcurrentHashMap 的效率要高于Hashtable，因为Hashtable给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在JDK1.7中采用分段锁实现线程安全，在JDK1.8 中采用"),s("code",[a._v("CAS+Synchronized")]),a._v("实现线程安全。")]),a._v(" "),s("h2",{attrs:{id:"_25-说一下hashtable的锁机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_25-说一下hashtable的锁机制"}},[a._v("#")]),a._v(" 25. 说一下Hashtable的锁机制 ?")]),a._v(" "),s("p",[a._v("Hashtable是使用Synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/ConcurrentHashMap-hashtable.png",alt:""}})]),a._v(" "),s("h2",{attrs:{id:"_26-多线程下安全的操作-map还有其他方法吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_26-多线程下安全的操作-map还有其他方法吗"}},[a._v("#")]),a._v(" 26. 多线程下安全的操作 map还有其他方法吗？")]),a._v(" "),s("p",[a._v("还可以使用"),s("code",[a._v("Collections.synchronizedMap")]),a._v("方法，对方法进行加同步锁")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SynchronizedMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Serializable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" serialVersionUID "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1978198479659022715L")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Backing Map")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v("      mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Object on which to synchronize")]),a._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SynchronizedMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("m "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Objects")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("requireNon "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            mutex "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SynchronizedMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("m "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("mutex "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 省略部分代码")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br")])]),s("p",[a._v("如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。"),s("strong",[a._v("在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！")])]),a._v(" "),s("h2",{attrs:{id:"_27-hashset-和-hashmap-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_27-hashset-和-hashmap-区别"}},[a._v("#")]),a._v(" 27. HashSet 和 HashMap 区别?")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://blog-img.coolsen.cn/img/image-20210403193010949.png",alt:""}})]),a._v(" "),s("p",[a._v("补充HashSet的实现：HashSet的底层其实就是HashMap，只不过我们"),s("strong",[a._v("HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存")]),a._v("。如源码所示：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("E")]),a._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("put")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("PRESENT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[a._v("由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性。")]),a._v(" "),s("h2",{attrs:{id:"_28-collection框架中实现比较要怎么做"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_28-collection框架中实现比较要怎么做"}},[a._v("#")]),a._v(" 28. Collection框架中实现比较要怎么做？")]),a._v(" "),s("p",[a._v("第一种，实体类实现Comparable接口，并实现 compareTo(T t) 方法，称为内部比较器。")]),a._v(" "),s("p",[a._v("第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 compare(T t1, T t2)方法。")]),a._v(" "),s("h2",{attrs:{id:"_29-iterator-和-listiterator-有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_29-iterator-和-listiterator-有什么区别"}},[a._v("#")]),a._v(" 29. Iterator 和 ListIterator 有什么区别？")]),a._v(" "),s("ul",[s("li",[a._v("遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的元素。")])]),a._v(" "),s("p",[a._v("使用ListIterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("添加元素。Iterator无法向集合中添加元素；而，ListIteror可以向集合添加元素。")])]),a._v(" "),s("li",[s("p",[a._v("修改元素。Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。")])]),a._v(" "),s("li",[s("p",[a._v("索引。Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。")])])]),a._v(" "),s("h2",{attrs:{id:"_30-讲一讲快速失败-fail-fast-和安全失败-fail-safe"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_30-讲一讲快速失败-fail-fast-和安全失败-fail-safe"}},[a._v("#")]),a._v(" 30. 讲一讲快速失败(fail-fast)和安全失败(fail-safe)")]),a._v(" "),s("p",[s("strong",[a._v("快速失败（fail—fast）")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。")])]),a._v(" "),s("li",[s("p",[a._v("原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个        modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。")])]),a._v(" "),s("li",[s("p",[a._v("注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。")])]),a._v(" "),s("li",[s("p",[a._v("场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如HashMap、ArrayList 这些集合类。")])])]),a._v(" "),s("p",[s("strong",[a._v("安全失败（fail—safe）")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。")])]),a._v(" "),s("li",[s("p",[a._v("原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。")])]),a._v(" "),s("li",[s("p",[a._v("缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。")])]),a._v(" "),s("li",[s("p",[a._v("场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如：ConcurrentHashMap。")])])]),a._v(" "),s("h2",{attrs:{id:"巨人的肩膀"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#巨人的肩膀"}},[a._v("#")]),a._v(" 巨人的肩膀")]),a._v(" "),s("p",[a._v("https://juejin.cn/post/6844903966103306247")]),a._v(" "),s("p",[a._v("https://www.javazhiyin.com/71751.html")]),a._v(" "),s("p",[a._v("https://blog.csdn.net/qq_31780525/article/details/77431970")]),a._v(" "),s("p",[a._v("https://www.cnblogs.com/zeroingToOne/p/9522814.html")])])}),[],!1,null,null,null);s.default=e.exports}}]);