(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{544:function(a,_,t){"use strict";t.r(_);var s=t(1),v=Object(s.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"精讲垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#精讲垃圾回收算法"}},[a._v("#")]),a._v(" "),_("strong",[a._v("精讲垃圾回收算法")])]),a._v(" "),_("p",[a._v("关于JVM的垃圾收集我准备这样讲：")]),a._v(" "),_("p",[a._v("首先把相关的算法给大家讲明白")]),a._v(" "),_("p",[a._v("然后将几款垃圾回收器结合算法给大家讲明白")]),a._v(" "),_("p",[a._v("最后等大家把C++学完带着大家读读垃圾收集器的源码")]),a._v(" "),_("p",[a._v("Java程序在运行过程中会产生大量的对象，但是内存大小是有限的，如果光用而不释放，那内存迟早被耗尽。如C、C++程序，需要程序猿手动释放内存，Java则不需要，是由垃圾回收器去自动回收。")]),a._v(" "),_("p",[a._v("垃圾回收器回收内存至少需要做两件事情：标记垃圾、回收垃圾。于是诞生了很多算法。本节课的重点就是深入理解这些算法。下节课就是探讨各种垃圾收集器。")]),a._v(" "),_("p",[_("strong",[a._v("垃圾收集器涉及到的算法如何不学明白，垃圾回收器是学不明白的。同学们要重视算法的学习！学会了，你就超越了很多同龄人。")])]),a._v(" "),_("h1",{attrs:{id:"垃圾判断算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾判断算法"}},[a._v("#")]),a._v(" 垃圾判断算法")]),a._v(" "),_("p",[a._v("即判断JVM中的所有对象，哪些对象是存活的，哪些对象可回收的算法。")]),a._v(" "),_("h2",{attrs:{id:"引用计数算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[a._v("#")]),a._v(" 引用计数算法")]),a._v(" "),_("p",[a._v("最简单的垃圾判断算法。")]),a._v(" "),_("p",[a._v("在对象中添加一个属性用于标记对象被引用的次数，每多一个其他对象引用，计数+1，当引用失效时，计数-1，如果计数=0，表示没有其他对象引用，就可以被回收。")]),a._v(" "),_("p",[a._v("这个算法无法解决循环依赖的问题。")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/2179815/1596698371136-794a2fb9-1926-4b68-a682-a02997a7161a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),a._v(" "),_("h2",{attrs:{id:"可达性分析算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[a._v("#")]),a._v(" 可达性分析算法")]),a._v(" "),_("p",[a._v("通过一系列被称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系链向下搜索，如果某个对象无法被搜索到，则说明该对象无引用执行，可回收。相反，则对象处于存活状态，不可回收。")]),a._v(" "),_("p",[a._v("JVM中的实现是找到存活对象，未打标记的就是无用对象，GC时会回收。")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/2179815/1596698789213-5e54eb88-0a34-42ec-9194-52fe5571f177.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_30%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),a._v(" "),_("p",[a._v("哪些对象可以作为GC Root呢：")]),a._v(" "),_("ul",[_("li",[a._v("所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。")]),a._v(" "),_("li",[a._v("VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。")]),a._v(" "),_("li",[a._v("JNI handles，包括global handles和local handles")]),a._v(" "),_("li",[a._v("（看情况）所有当前被加载的Java类")]),a._v(" "),_("li",[a._v("（看情况）Java类的引用类型静态变量")]),a._v(" "),_("li",[a._v("（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）")]),a._v(" "),_("li",[a._v("（看情况）String常量池（StringTable）里的引用")])]),a._v(" "),_("h1",{attrs:{id:"内存池"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存池"}},[a._v("#")]),a._v(" 内存池")]),a._v(" "),_("p",[_("strong",[a._v("具体细节见课堂上操作实战")])]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/2179815/1596789802671-d3fedd57-8ae9-47e0-bacd-345bdc2fb384.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/2179815/1596789878642-56a64d4b-4d39-4e43-9cb3-376a1f3bf440.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),a._v(" "),_("h1",{attrs:{id:"垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收算法")]),a._v(" "),_("p",[_("strong",[a._v("具体细节见课堂上操作实战")])]),a._v(" "),_("h2",{attrs:{id:"_1、标记-清除算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、标记-清除算法"}},[a._v("#")]),a._v(" 1、标记-清除算法")]),a._v(" "),_("h2",{attrs:{id:"_2、标记-整理算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、标记-整理算法"}},[a._v("#")]),a._v(" 2、标记-整理算法")]),a._v(" "),_("h2",{attrs:{id:"_3、标记-复制算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、标记-复制算法"}},[a._v("#")]),a._v(" 3、标记-复制算法")]),a._v(" "),_("h1",{attrs:{id:"三色标记与读写屏障"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三色标记与读写屏障"}},[a._v("#")]),a._v(" 三色标记与读写屏障")]),a._v(" "),_("p",[a._v("所有的垃圾回收算法都要经历标记阶段。如果GC线程在标记的时候暂停所有用户线程（STW），那就没三色标记什么事了。但是这样会有一个问题，用户线程需要等到GC线程标记完才能运行，给用户的感觉就是很卡，用户体验很差。")]),a._v(" "),_("p",[a._v("现在主流的垃圾收集器都支持并发标记。什么是并发标记呢？就是标记的时候不暂停或少暂停用户线程，一起运行。这势必会带来三个问题：多标、少标、漏标。垃圾收集器是如何解决这个问题的呢：三色标记+读写屏障。")]),a._v(" "),_("h2",{attrs:{id:"三色标记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三色标记"}},[a._v("#")]),a._v(" 三色标记")]),a._v(" "),_("p",[a._v("把遍历对象过程中遇到的对象，按照“是否访问过”这个条件标记成三种颜色：")]),a._v(" "),_("ul",[_("li",[_("strong",[a._v("白色")]),a._v("：尚未访问过。")]),a._v(" "),_("li",[_("strong",[a._v("黑色")]),a._v("：本对象已访问过，而且本对象 引用到 的其他对象 也全部访问过了。")]),a._v(" "),_("li",[_("strong",[a._v("灰色")]),a._v("：本对象已访问过，但是本对象 引用到 的其他对象 尚未全部访问完。全部访问后，会转换为黑色。")])]),a._v(" "),_("p",[a._v("有个问题同学们可以自己先想想：对象上的标记是何时清除的？")]),a._v(" "),_("h2",{attrs:{id:"读写屏障"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读写屏障"}},[a._v("#")]),a._v(" 读写屏障")]),a._v(" "),_("p",[a._v("有点像Spring的AOP")]),a._v(" "),_("p",[a._v("1、读屏障")]),a._v(" "),_("p",[a._v("即在读前增加屏障做点事情")]),a._v(" "),_("div",{staticClass:"language-plain line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-plain"}},[_("code",[a._v("读屏障()\n读操作\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br"),_("span",{staticClass:"line-number"},[a._v("2")]),_("br")])]),_("p",[a._v("2、写屏障")]),a._v(" "),_("p",[a._v("即在写的前后增加屏障做点事情")]),a._v(" "),_("div",{staticClass:"language-plain line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-plain"}},[_("code",[a._v("写前屏障()\n写操作\n写后屏障()\n")])]),a._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[a._v("1")]),_("br"),_("span",{staticClass:"line-number"},[a._v("2")]),_("br"),_("span",{staticClass:"line-number"},[a._v("3")]),_("br")])]),_("h2",{attrs:{id:"详解三个问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#详解三个问题"}},[a._v("#")]),a._v(" 详解三个问题")]),a._v(" "),_("p",[a._v("1、多标 浮动垃圾")]),a._v(" "),_("p",[a._v("GC线程已经标记了B，此时用户代码中A断开了对B的引用，但此时B已经被标记成了灰色，本轮GC不会被回收，这就是所谓的多标，多标的对象即成为浮动垃圾，躲过了本次GC。")]),a._v(" "),_("p",[a._v("多标对程序逻辑是没有影响的，唯一的影响是该回收的对象躲过了一次GC，造成了些许的内存浪费。")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/2179815/1596782478179-047a23b0-9e59-4cc9-a44f-ed2c292bfd72.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),a._v(" "),_("p",[a._v("2、少标 浮动垃圾")]),a._v(" "),_("p",[a._v("并发标记开始后创建的对象，都视为黑色，本轮GC不清除。")]),a._v(" "),_("p",[a._v("这里面有的对象用完就变成垃圾了，就可以销毁了，这部分对象即少标环境中的浮动垃圾。")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/2179815/1596782779554-b178516f-3bee-465f-9824-f7f03f5a3379.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),a._v(" "),_("p",[a._v("3、漏标 程序会出错")]),a._v(" "),_("p",[a._v("漏标是如何产生的呢？GC把B标记完，准备标记B引用的对象，这时用户线程执行代码，代码中断开了B对D的引用，改为A对D的引用。但是A已经被标记成黑色，不会再次扫描A，而D还是白色，执行垃圾回收逻辑的时候D会被回收，程序就会出错了。")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/2179815/1596782802771-b5340894-6190-4023-aa19-ab83c5e0e492.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),a._v(" "),_("h2",{attrs:{id:"如何解决漏标问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决漏标问题"}},[a._v("#")]),a._v(" 如何解决漏标问题")]),a._v(" "),_("p",[a._v("先分析下漏标问题是如何产生的：")]),a._v(" "),_("p",[a._v("条件一：灰色对象 断开了 白色对象的引用；即灰色对象 原来成员变量的引用 发生了变化。")]),a._v(" "),_("p",[a._v("条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。")]),a._v(" "),_("p",[a._v("知道了问题所在就知道如何解决了")]),a._v(" "),_("h4",{attrs:{id:"_1、读屏障-重新标记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、读屏障-重新标记"}},[a._v("#")]),a._v(" 1、读屏障 + 重新标记")]),a._v(" "),_("p",[a._v("在建立A对D的引用时将D作为白色或灰色对象记录下来，并发标记结束后STW，然后重新标记由D类似的对象组成的集合。")]),a._v(" "),_("p",[a._v("重新标记环节一定要STW，不然标记就没完没了了。")]),a._v(" "),_("h4",{attrs:{id:"_2、写屏障-增量更新-iu"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、写屏障-增量更新-iu"}},[a._v("#")]),a._v(" 2、写屏障 + 增量更新（IU）")]),a._v(" "),_("p",[a._v("这种方式解决的是条件二，即通过写屏障记录下更新，具体做法如下：")]),a._v(" "),_("p",[a._v("对象A对D的引用关系建立时，将D加入带扫描的集合中等待扫描")]),a._v(" "),_("h4",{attrs:{id:"_3、写屏障-原始快照-satb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、写屏障-原始快照-satb"}},[a._v("#")]),a._v(" 3、写屏障 + 原始快照（SATB）")]),a._v(" "),_("p",[a._v("这种方式解决的是条件一，带来的结果是依然能够标记到D，具体做法如下：")]),a._v(" "),_("p",[a._v("对象B的引用关系变动的时候，即给B对象中的某个属性赋值时，将之前的引用关系记录下来。")]),a._v(" "),_("p",[a._v("标记的时候，扫描旧的对象图，这个旧的对象图即原始快照。")]),a._v(" "),_("h4",{attrs:{id:"_4、实际应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、实际应用"}},[a._v("#")]),a._v(" 4、实际应用")]),a._v(" "),_("p",[a._v("CMS：写屏障 + 增量更新")]),a._v(" "),_("p",[a._v("G1：写屏障 + SATB")]),a._v(" "),_("h1",{attrs:{id:"记忆集与卡表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#记忆集与卡表"}},[a._v("#")]),a._v(" 记忆集与卡表")]),a._v(" "),_("p",[a._v("这个东西过于复杂，课堂上不准备讲，我之前写过文章，感兴趣的可以看看，有问题找我探讨")]),a._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/2179815/1596784743887-541d09fd-b6a6-417d-a2b7-7023989987b7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})]),a._v(" "),_("h1",{attrs:{id:"练习"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#练习"}},[a._v("#")]),a._v(" 练习")]),a._v(" "),_("p",[a._v("1、针对课堂上讲的所有算法自己写成笔记或文章")]),a._v(" "),_("p",[a._v("2、可以试着用java实现基础的GC算法：标清、标整、分代+赋值算法（不难，别怕）")]),a._v(" "),_("h1",{attrs:{id:""}},[_("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])])])}),[],!1,null,null,null);_.default=v.exports}}]);