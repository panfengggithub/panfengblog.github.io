(window.webpackJsonp=window.webpackJsonp||[]).push([[423],{833:function(t,a,_){"use strict";_.r(a);var r=_(1),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"设计模式开篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式开篇"}},[t._v("#")]),t._v(" "),a("strong",[t._v("设计模式开篇")])]),t._v(" "),a("h1",{attrs:{id:"_1-设计模式简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-设计模式简介"}},[t._v("#")]),t._v(" 1. 设计模式简介")]),t._v(" "),a("ul",[a("li",[t._v("设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。")]),t._v(" "),a("li",[t._v("设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。")]),t._v(" "),a("li",[t._v("设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。")]),t._v(" "),a("li",[t._v("设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。")]),t._v(" "),a("li",[t._v("项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。")])]),t._v(" "),a("h1",{attrs:{id:"_2-什么是-gof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是-gof"}},[t._v("#")]),t._v(" 2. 什么是 GOF？")]),t._v(" "),a("ul",[a("li",[t._v("在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 "),a("strong",[t._v("Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）")]),t._v(" 的书，该书首次提到了软件开发中设计模式的概念。")])]),t._v(" "),a("p",[t._v("​      图书链接：https://book.douban.com/subject/1052241/")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("四位作者合称 "),a("strong",[t._v("GOF（四人帮，全拼 Gang of Four）")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("他们所提出的设计模式主要是基于以下的面向对象设计原则：")])]),t._v(" "),a("li",[a("ul",[a("li",[t._v("对接口编程而不是对实现编程。")]),t._v(" "),a("li",[t._v("优先使用对象组合而不是继承。")])])])]),t._v(" "),a("h1",{attrs:{id:"_3-23种设计模式的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-23种设计模式的类型"}},[t._v("#")]),t._v(" 3. 23种设计模式的类型")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("根据设计模式的参考书 "),a("strong",[t._v("Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）")]),t._v(" 中所提到的，总共有 23 种设计模式。")])]),t._v(" "),a("li",[a("p",[t._v("这些模式可以分为三大类：")])]),t._v(" "),a("li",[a("ul",[a("li",[t._v("创建型模式（Creational Patterns）")]),t._v(" "),a("li",[t._v("结构型模式（Structural Patterns）")]),t._v(" "),a("li",[t._v("行为型模式（Behavioral Patterns）")]),t._v(" "),a("li",[t._v("还有另一类设计模式：J2EE 设计模式。")])])])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("序号")]),t._v(" "),a("th",[t._v("模式 & 描述")]),t._v(" "),a("th",[t._v("包括")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("1")]),t._v(" "),a("td",[a("strong",[t._v("创建型模式")]),t._v("这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。")]),t._v(" "),a("td",[t._v("工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）")])]),t._v(" "),a("tr",[a("td",[t._v("2")]),t._v(" "),a("td",[a("strong",[t._v("结构型模式")]),t._v("这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。")]),t._v(" "),a("td",[t._v("适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）")])]),t._v(" "),a("tr",[a("td",[t._v("3")]),t._v(" "),a("td",[a("strong",[t._v("行为型模式")]),t._v("这些设计模式特别关注对象之间的通信，负责对象间的高效沟通和职责委派。")]),t._v(" "),a("td",[t._v("责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）")])]),t._v(" "),a("tr",[a("td",[t._v("4")]),t._v(" "),a("td",[a("strong",[t._v("J2EE 模式")]),t._v("这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。")]),t._v(" "),a("td",[t._v("MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）")])])])]),t._v(" "),a("h1",{attrs:{id:"_4-模式之间的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-模式之间的关系"}},[t._v("#")]),t._v(" 4. 模式之间的关系")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/jpeg/10385897/1609591343717-22b8fd21-7e42-48fb-a522-38dc7c391c1b.jpeg",alt:"img"}})]),t._v(" "),a("h1",{attrs:{id:"_5-设计模式六大原则与核心思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-设计模式六大原则与核心思想"}},[t._v("#")]),t._v(" 5. 设计模式六大原则与核心思想")]),t._v(" "),a("h2",{attrs:{id:"_5-1-六大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-六大原则"}},[t._v("#")]),t._v(" 5.1 六大原则")]),t._v(" "),a("p",[a("strong",[t._v("1、开闭原则（Open Close Principle）")])]),t._v(" "),a("p",[t._v("开闭原则的意思是："),a("strong",[t._v("对扩展开放，对修改关闭")]),t._v("。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。")]),t._v(" "),a("p",[a("strong",[t._v("2、里氏代换原则（Liskov Substitution Principle）")])]),t._v(" "),a("p",[t._v("里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。")]),t._v(" "),a("p",[a("strong",[t._v("3、依赖倒转原则（Dependence Inversion Principle）")])]),t._v(" "),a("p",[t._v("这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。")]),t._v(" "),a("p",[a("strong",[t._v("4、接口隔离原则（Interface Segregation Principle）")])]),t._v(" "),a("p",[t._v("这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。")]),t._v(" "),a("p",[a("strong",[t._v("5、迪米特法则，又称最少知道原则（Demeter Principle）")])]),t._v(" "),a("p",[t._v("最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。")]),t._v(" "),a("p",[a("strong",[t._v("6、合成复用原则（Composite Reuse Principle）")])]),t._v(" "),a("p",[t._v("合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。")]),t._v(" "),a("h2",{attrs:{id:"_5-2-核心思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-核心思想"}},[t._v("#")]),t._v(" 5.2 核心思想")]),t._v(" "),a("ol",[a("li",[t._v("找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。")]),t._v(" "),a("li",[t._v("针对接口编程，而不是针对实现编程。")]),t._v(" "),a("li",[t._v("为了交互对象之间的松耦合设计而努力")])]),t._v(" "),a("h1",{attrs:{id:"_6-类之间的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-类之间的关系"}},[t._v("#")]),t._v(" 6. 类之间的关系")]),t._v(" "),a("p",[a("strong",[t._v("在类之间， 最常见的关系有：")])]),t._v(" "),a("ol",[a("li",[t._v("泛化/继承（Generalization）")]),t._v(" "),a("li",[t._v("实现（Realization）")]),t._v(" "),a("li",[t._v("依赖(Dependency)")]),t._v(" "),a("li",[t._v("关联（Association)")]),t._v(" "),a("li",[t._v("聚合（Aggregation）")]),t._v(" "),a("li",[t._v("组合(Composition)")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749430-5103a2e6-faf4-401e-8c74-103772552c18.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_6-1-泛化-继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-泛化-继承"}},[t._v("#")]),t._v(" 6.1   泛化/继承")]),t._v(" "),a("ul",[a("li",[t._v("含义：继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。")]),t._v(" "),a("li",[t._v("代码体现：在Java中继承关系通过关键字"),a("code",[t._v("extends")]),t._v("明确标识")]),t._v(" "),a("li",[t._v("箭头指向：继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749634-777ce212-e3da-4896-be30-9656c3e6c3f1.png",alt:"img"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749510-74febf88-7adc-41f8-bca0-6421b600808b.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_6-2-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-实现"}},[t._v("#")]),t._v(" 6.2  实现")]),t._v(" "),a("ul",[a("li",[t._v("含义：实现指的是一个class类实现interface接口（可以是多个）的功能，实现是类与接口之间最常见的关系。")]),t._v(" "),a("li",[t._v("代码体现：在Java中此类关系通过关键字"),a("code",[t._v("implements")]),t._v("明确标识")]),t._v(" "),a("li",[t._v("箭头指向：实现用一条带空心三角箭头的虚线表示，从类指向实现的接口。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749619-5f59c113-b84d-4833-bc03-b8f1932658c5.png",alt:"img"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749555-c6582818-d14c-472e-be41-a670ff439b4d.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_6-3-依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-依赖"}},[t._v("#")]),t._v(" 6.3 依赖")]),t._v(" "),a("ul",[a("li",[t._v("含义：一种使用的关系，即一个类的实现需要另一个类的协助，要尽量不使用双向的互相依赖.\n这种使用关系是具有偶然性的、临时性的、非常弱的，类B的变化会影响到类A。")]),t._v(" "),a("li",[t._v("代码表现："),a("code",[t._v("局部变量、方法的参数或者对静态方法的调用；")]),t._v("类B作为方法参数(局部变量)被类A在某个method方法中使用")]),t._v(" "),a("li",[t._v("箭头指向：用带箭头的虚线表示，指向被使用者")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749657-e48b63ef-08b1-48c6-9c15-d659f7555db0.png",alt:"img"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749608-1dc32b18-2b20-425d-a4c8-1db63becee4b.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_6-4-关联"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-关联"}},[t._v("#")]),t._v(" 6.4 关联")]),t._v(" "),a("ul",[a("li",[t._v("含义：是一种拥有的关系，它使一个类知道另一个类的属性和方法；\n这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。\n如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。")]),t._v(" "),a("li",[t._v("代码体现："),a("code",[t._v("成员变量。")]),t._v("被关联类B以类的属性形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。")]),t._v(" "),a("li",[t._v("箭头指向： 带普通箭头的实心线，指向被拥有者")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749594-940e25fe-5d02-4965-87af-90decfaa53b8.png",alt:"img"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749502-9f374120-0d26-4fe8-aeb7-93850ab5e7b2.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_6-5-聚合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-聚合"}},[t._v("#")]),t._v(" 6.5 聚合")]),t._v(" "),a("ul",[a("li",[t._v("含义：聚合是关联关系的一种特例，它体现的是整体与部分的关系，即has-a的关系。\n此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。\n比如计算机与CPU、公司与员工的关系等，比如一个航母编队包括海空母舰、驱护舰艇、舰载飞机及核动力攻击潜艇等。")]),t._v(" "),a("li",[t._v("代码体现：成员变量；和关联关系是一致的，只能从语义级别来区分")]),t._v(" "),a("li",[t._v("箭头指向：带空心菱形的实心线，菱形指向整体")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749681-1a872290-8373-4978-a9a2-30fec286d542.png",alt:"img"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749608-d26b85ba-eb61-4688-a11e-70dd78a05a2c.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_6-6-组合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-组合"}},[t._v("#")]),t._v(" 6.6  组合")]),t._v(" "),a("ul",[a("li",[t._v("含义：组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，\n比如人和人的大脑。比如公司和部门是整体和部分的关系，没有公司就不存在部门。")]),t._v(" "),a("li",[t._v("代码体现：成员变量；和关联关系是一致的，只能从语义级别来区分")]),t._v(" "),a("li",[t._v("箭头指向：带实心菱形的实线，菱形指向整体")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749889-74043ffe-4a0c-430c-a04f-40a04339bb59.png",alt:"img"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749979-8ea6fc94-0947-42d4-8aaa-3647c960e571.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_6-7-强弱顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-强弱顺序"}},[t._v("#")]),t._v(" 6.7 强弱顺序")]),t._v(" "),a("p",[t._v("各种关系的强弱顺序："),a("strong",[t._v("泛化/继承 = 实现 > 组合 > 聚合 > 关联 > 依赖")])]),t._v(" "),a("h3",{attrs:{id:"_6-8-一张图融会贯通"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-8-一张图融会贯通"}},[t._v("#")]),t._v(" 6.8 一张图融会贯通")]),t._v(" "),a("p",[t._v("下面这张UML图，比较形象地展示了各种类图关系：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/10385897/1609591749923-9177bca1-a4fb-456a-befb-c98dd23a0929.png",alt:"img"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);