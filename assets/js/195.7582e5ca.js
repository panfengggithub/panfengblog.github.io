(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{579:function(n,a,t){"use strict";t.r(a);var e=t(1),i=Object(e.a)({},(function(){var n=this,a=n._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"spring中bean的生命周期详解-下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring中bean的生命周期详解-下"}},[n._v("#")]),n._v(" "),a("strong",[n._v("Spring中Bean的生命周期详解(下)")])]),n._v(" "),a("h2",{attrs:{id:"spring中的-父子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring中的-父子"}},[n._v("#")]),n._v(" Spring中的“父子”")]),n._v(" "),a("ol",[a("li",[n._v("父子类")]),n._v(" "),a("li",[n._v("父子BeanDefinition")]),n._v(" "),a("li",[n._v("父子BeanFactory")]),n._v(" "),a("li",[n._v("父子ApplicationContext")])]),n._v(" "),a("h3",{attrs:{id:"父子类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子类"}},[n._v("#")]),n._v(" 父子类")]),n._v(" "),a("p",[n._v("父子类是Java中的概念，在Spring中，当给某个类创建Bean的过程中，Spring不仅仅会对本类中的属性进行自动注入，同时也会对父类的属性进行自动注入。")]),n._v(" "),a("h3",{attrs:{id:"父子beandefinition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子beandefinition"}},[n._v("#")]),n._v(" 父子BeanDefinition")]),n._v(" "),a("p",[n._v("父子BeanDefinition是Spring中的概念，Spring在根据BeanDefinition创建Bean的过程中，会先看当前BeanDefinition是否存在父BeanDefinition，如果存在则需要进行合并，合并就是把子BeanDefinition和父BeanDefinition中所定义的属性整合起来（如果存在某个属性在父子BeanDefinition中都存在，那么取子BeanDefinition中的属性）")]),n._v(" "),a("h3",{attrs:{id:"父子beanfactory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子beanfactory"}},[n._v("#")]),n._v(" 父子BeanFactory")]),n._v(" "),a("p",[n._v("BeanFactory是一个Bean的容器，在Spring中，当我们在使用某个BeanFactory去获取Bean时，如果本BeanFactory中不存在该Bean，同时又有父BeanFactory，那么则会检查父BeanFactory是否存在该Bean，如果也不存在，那么则会创建Bean")]),n._v(" "),a("h3",{attrs:{id:"父子applicationcontext"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子applicationcontext"}},[n._v("#")]),n._v(" 父子ApplicationContext")]),n._v(" "),a("p",[n._v("父子ApplicationContext和父子BeanFactory类似，子ApplicationContext除开可以使用父ApplicationContext来获取Bean之外，还可以使用父ApplicationContext中其他的东西，比如ApplicationListener")]),n._v(" "),a("h2",{attrs:{id:"beanpostprocessor-bean的后置处理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beanpostprocessor-bean的后置处理器"}},[n._v("#")]),n._v(" BeanPostProcessor(Bean的后置处理器)")]),n._v(" "),a("p",[n._v("Bean的后置处理器是指Spring在创建一个Bean的过程中，可以通过后置处理器来干涉Bean的创建过程")]),n._v(" "),a("p",[n._v("一个简单的Bean的生命周期：")]),n._v(" "),a("ol",[a("li",[n._v("推断构造方法(确定使用哪个构造方法来实例化对象)")]),n._v(" "),a("li",[n._v("实例化")]),n._v(" "),a("li",[n._v("填充属性")]),n._v(" "),a("li",[n._v("初始化")])]),n._v(" "),a("p",[n._v('Spring在这个基础上，在这4步中的某些"间隙"中增加了扩展点，比如：')]),n._v(" "),a("ol",[a("li",[a("strong",[n._v("BeanPostProcessor")]),n._v("：提供了"),a("strong",[n._v("初始化前")]),n._v("、"),a("strong",[n._v("初始化后")])]),n._v(" "),a("li",[a("strong",[n._v("InstantiationAwareBeanPostProcessor")]),n._v("：在BeanPostProcessor的基础上增加了"),a("strong",[n._v("实例化前")]),n._v("、"),a("strong",[n._v("实例化后")]),n._v("、"),a("strong",[n._v("填充属性后")])]),n._v(" "),a("li",[a("strong",[n._v("MergedBeanDefinitionPostProcessor")]),n._v("：在BeanPostProcessor的基础上增加了在实例化和实例化后"),a("strong",[n._v("之间")]),n._v("的扩展点")])]),n._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/365147/1602741327588-d86d7022-77a9-4ea2-b889-d867b1ecad4c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_71%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10",alt:"img"}})])])}),[],!1,null,null,null);a.default=i.exports}}]);